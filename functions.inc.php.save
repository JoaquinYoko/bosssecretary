<?php


/********************************************************
*														*
* 					API FUNCTIONS						*
*														*
********************************************************/


define("BOSSSECRETARY_PARAM_PREFIX", "bsgroup-");
define("BOSSSECRETARY_LABEL_DEFAULT", "Group ");
define("BOSSSECRETARY_CONTEXT", "ext-bosssecretary");
define("BOSSSECRETARY_MACRO_LOCKED", "macro-bosssecretary-locked");
define("BOSSSECRETARY_MACRO_LOCKED_NAME", "bosssecretary-locked");
define("BOSSSECRETARY_TOGGLE", "app-bosssecretary-toggle");
define("BOSSSECRETARY_ON", "app-bosssecretary-on");
define("BOSSSECRETARY_OFF", "app-bosssecretary-off");
define("BOSSSECRETARY_HINTS", "app-bosssecretary-hints");


function bosssecretary_get_config($engine){
	global $db;
	global $ext;
	global $amp_conf;
	global $astman;

	switch($engine) {
		case "asterisk":




			$fcc_toggle = bosssecretary_get_fcc_toggle();
			$fcc_on  = bosssecretary_get_fcc_on();
			$fcc_off  = bosssecretary_get_fcc_off();
			$groups = bosssecretary_get_all_groups();

			$ctx_app_toggle =   BOSSSECRETARY_TOGGLE;
			$ctx_app_on     =   BOSSSECRETARY_ON;
			$ctx_app_off    =   BOSSSECRETARY_OFF;
			$ctx_app_hints	=	BOSSSECRETARY_HINTS;
			$ctx_bsc		=	BOSSSECRETARY_CONTEXT;

			$ext->addInclude('from-internal-additional', $ctx_bsc);
			$ext->addInclude($ctx_bsc, $ctx_app_toggle);
			$ext->addInclude($ctx_bsc, $ctx_app_on);
			$ext->addInclude($ctx_bsc, $ctx_app_off);
			$ext->addInclude($ctx_bsc, $ctx_app_hints);

			if (!empty($groups))
			{

				$astman->database_deltree("bosssecretary/group");
				$groups = bosssecretary_to_group($groups);



				foreach ($groups as $group)
				{
					$id_group = $group["id_group"];

					foreach ($group["bosses"] as $extension)
					{
						$astman->database_put("bosssecretary","group/$id_group/member/$extension", "boss");
						$astman->database_put("bosssecretary","group/member/$extension", $id_group);
					}
					foreach ($group["secretaries"] as $extension)
					{
						$astman->database_put("bosssecretary","group/$id_group/member/$extension", "secretary");
						$astman->database_put("bosssecretary","group/member/$extension", $id_group);
					}
					foreach ($group["chiefs"] as $extension)
					{
						$astman->database_put("bosssecretary","group/$id_group/member/$extension", "chief");
					}
				}
				// :::: BSC Off [app-bosssecretary-on] ::::

				$ext->add($ctx_app_on, $fcc_on, '', new ext_noop("Bosssecretary on starts..."));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_answer());
				$ext->add($ctx_app_on, $fcc_on, '', new ext_macro ('user-callerid'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_wait ('2'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_gotoif('${DB_EXISTS(bosssecretary/group/member/${AMPUSER})}','on','exit'));
				$ext->add($ctx_app_on, $fcc_on, 'on', new ext_setvar('GROUP','${DB(bosssecretary/group/member/${AMPUSER})}'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_dbdel('bosssecretary/group/${GROUP}/locked'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_setvar('STATE','NOT_INUSE'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_gosub('1','sstate',$ctx_app_on));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_playback('activated'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_hangup());
				$ext->add($ctx_app_on, $fcc_on, 'exit', new ext_noop('${AMPUSER} doesn\\\'t belongs bosssecretary group'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_hangup());
				$ext->add($ctx_app_on, 'sstate', '', new ext_setvar('DEVICE_STATE(Custom:BSC${GROUP})','${STATE}'));
				$ext->add($ctx_app_on, 'sstate', 'return', new ext_return());


				// :::: BSC Off [app-bosssecretary-off] ::::
				$ext->add($ctx_app_off, $fcc_off, '', new ext_noop("Bosssecretary off starts..."));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_answer());
				$ext->add($ctx_app_off, $fcc_off, '', new ext_macro ('user-callerid'));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_wait ('2'));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_gotoif('${DB_EXISTS(bosssecretary/group/member/${AMPUSER})}','off','exit'));
				$ext->add($ctx_app_off, $fcc_off, 'off', new ext_setvar('GROUP','${DB(bosssecretary/group/member/${AMPUSER})}'));
				$ext->add($ctx_app_off, $fcc_off, "", new ext_setvar('DB(bosssecretary/group/${GROUP}/locked)',"1"));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_setvar('STATE','INUSE'));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_gosub('1','sstate',$ctx_app_off));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_playback('de-activated'));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_hangup());
				$ext->add($ctx_app_off, $fcc_off, 'exit', new ext_noop('${AMPUSER} doesn\\\'t belongs bosssecretary group'));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_hangup());
				$ext->add($ctx_app_off, 'sstate', '', new ext_setvar('DEVICE_STATE(Custom:BSC${GROUP})','${STATE}'));
				$ext->add($ctx_app_off, 'sstate', 'return', new ext_return());

				// :::: BSC Toggle [app-bosssecretary-toggle] ::::
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_noop("Bosssecretary toggle starts..."));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_answer());
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_macro ('user-callerid'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_wait ('2'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_gotoif('${DB_EXISTS(bosssecretary/group/member/${AMPUSER})}','check','exit' ));
				$ext->add($ctx_app_toggle, $fcc_toggle, 'check', new ext_setvar('GROUP','${DB(bosssecretary/group/member/${AMPUSER})}'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_gotoif('${DB_EXISTS(bosssecretary/group/${GROUP}/locked)}','unlock', 'lock'));
				$ext->add($ctx_app_toggle, $fcc_toggle, "lock", new ext_setvar('DB(bosssecretary/group/${GROUP}/locked)',"1"));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_setvar('STATE','INUSE'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_gosub('1','sstate',$ctx_app_toggle));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_playback('de-activated'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_hangup());
				$ext->add($ctx_app_toggle, $fcc_toggle, 'unlock', new ext_dbdel('bosssecretary/group/${GROUP}/locked'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_setvar('STATE','NOT_INUSE'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_gosub('1','sstate',$ctx_app_toggle));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_playback('activated'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_hangup());
				$ext->add($ctx_app_toggle, $fcc_toggle, 'exit', new ext_noop('${AMPUSER} doesn\\\'t belongs bosssecretary group'));
				$ext->add($ctx_app_toggle, $fcc_toggle, '', new ext_hangup());
				$ext->add($ctx_app_toggle, 'sstate', '', new ext_setvar('DEVICE_STATE(Custom:BSC${GROUP})','${STATE}'));
				$ext->add($ctx_app_toggle, 'sstate', 'return', new ext_return());

				// :::: BSC Hints [app-bosssecretary-hints] ::::
				foreach ($groups as $group)
				{

					$id_group = $group["id_group"];
					foreach ($group["bosses"] as $extension)
					{
						$hint = "Custom:BSC$id_group";
						$ext_subscribed = $fcc_toggle . $extension;
						$ext->add($ctx_app_hints, $ext_subscribed, '', new ext_goto(1, $fcc_toggle, $ctx_app_toggle));
						$ext->addHint($ctx_app_hints, $ext_subscribed, $hint);

					}
					foreach ($group["secretaries"] as $extension)
					{
						$hint = "Custom:BSC$id_group";
						$ext_subscribed = $fcc_toggle . $extension;
						$ext->add($ctx_app_hints, $ext_subscribed, '', new ext_goto(1, $fcc_toggle, $ctx_app_toggle));
						$ext->addHint($ctx_app_hints, $ext_subscribed, $hint);
					}

				}

				// :::: BSC Context [ext-bosssecretary] ::::
				foreach ($groups as $group)
				{
					$AllExtensions = array_merge($group["bosses"], $group["secretaries"]);
					$id_group = $group["id_group"];

					foreach ($group["bosses"] as $extension)
					{
						$ext->add($ctx_bsc, $extension, '', new ext_noop("Bosssecretary: Checking  lock for $extension extension"));
						$ext->add($ctx_bsc, $extension, '', new ext_macro ('user-callerid'));
						$ext->add($ctx_bsc, $extension, '', new ext_setvar('CALLER','${CALLERID(num)}'));
						$ext->add($ctx_bsc, $extension, '', new ext_gotoif('${DB_EXISTS(bosssecretary/group/'.$id_group.'/member/${CALLER})}','exit_module'));
						$ext->add($ctx_bsc, $extension, '', new ext_gotoif('${DB_EXISTS(bosssecretary/group/'.$id_group.'/locked)}','exit_module','run_module'));
						$ext->add($ctx_bsc, $extension, 'run_module', new ext_noop("Bosssecretary: Executing module"));
						$ext->add($ctx_bsc, $extension, '', new ext_set("PJSIP_HEADER(add,Alert-Info)", "<http://nohost>;info=alert-group;x-line-id=0")); //ext_sipaddheader("Alert-Info", "<http://nohost>\;info=alert-group\;x-line-id=0"));
						$extensions = array();
						
						// David
						foreach ($group["secretaries"] as $sip_extension)
						{
							$extensions[] = "$sip_extension";
						}
						//	$extensions[] = "$extension";
						$args = '${RINGTIMER},${DIAL_OPTIONS},' . implode ("-", $extensions);
						$ext->add($ctx_bsc, $extension, '', new ext_macro ("dial", $args));
						$ext->add($ctx_bsc, $extension, 'exit_module', new ext_noop("Bosssecretary: Exit") );
						$ext->add($ctx_bsc, $extension, '', new ext_goto(1, $extension, "ext-local") );
						$extensions = "";
					}
				}
			}
				// Redirect calls from PSTN 
				$context = 'bosssecretary-routing';

$ext->add($context, '_.', '', new ext_noop('bosssecretary: call from PSTN'));
$ext->add($context, '_.', '', new ext_macro('user-callerid'));
//$ext->add('from-pstn', '_.', '', new ext_gotoif('$["${DB(bosssecretary/group/member/${EXTEN})}" = "boss"]', 'ext-bosssecretary,${EXTEN},1', 'from-pstn,${EXTEN},1'));
//$ext->add($context, '_.', '', new ext_execif('$["${DB(bosssecretary/group/member/${EXTEN})}" = "boss"]', 'Goto(ext-bosssecretary,${EXTEN},1)'));
//$ext->add($context, '_.', '', new ext_goto('from-pstn,${EXTEN},1')); 
				//$ext->add($context, '_.', '', new ext_noop('bosssecretary: call from PSTN, sending to ext-bosssecretary'));
				$ext->add($context, '_.', '', new ext_goto('ext-bosssecretary,${EXTEN},1'));
T√∫ dijiste:
tcpdump para capturar paquetes SIP


ChatGPT Plus
Para capturar paquetes SIP (Session Initiation Protocol) con tcpdump, pod√©s usar filtros que apunten al puerto SIP t√≠pico (5060 UDP o TCP), o incluso filtrar por contenido si es necesario. A continuaci√≥n te muestro varios ejemplos √∫tiles:

üî∏ 1. Capturar todo el tr√°fico SIP (puerto 5060)
bash
Copiar
Editar
sudo tcpdump -i any port 5060 -nn -vvv -s 0 -A
Explicaci√≥n:

-i any: escucha en todas las interfaces.

port 5060: filtra el puerto SIP est√°ndar.

-nn: no resuelve nombres ni puertos.

-vvv: modo muy detallado.

-s 0: captura el paquete completo.

-A: muestra el contenido en ASCII (√∫til para ver el contenido SIP legible).

üî∏ 2. Capturar tr√°fico SIP UDP solamente
bash
Copiar
Editar
sudo tcpdump -i any udp port 5060 -nn -vvv -s 0 -A
üî∏ 3. Capturar SIP desde o hacia una IP espec√≠fica
bash
Copiar
Editar
sudo tcpdump -i any port 5060 and host 192.168.1.100 -nn -vvv -s 0 -A
üî∏ 4. Capturar y guardar en archivo .pcap
bash
Copiar
Editar
sudo tcpdump -i any port 5060 -nn -s 0 -w sip_traffic.pcap
Luego pod√©s analizar ese archivo con Wireshark:

bash
Copiar
Editar
wireshark sip_traffic.pcap
üî∏ 5. Capturar SIP y RTP (puertos SIP + rango RTP, t√≠picamente 10000-20000)
bash
Copiar
Editar
sudo tcpdump -i any portrange 5060-20000 -nn -s 0 -w voip_full.pcap
üî∏ 6. Filtrar por m√©todo SIP (por contenido)
Si quer√©s capturar solo los paquetes que contienen el m√©todo SIP como INVITE, BYE, etc.:

bash
Copiar
Editar
sudo tcpdump -i any -nn -s 0 -A | grep -i "INVITE"
‚ö†Ô∏è Esto no es muy eficiente porque inspecciona texto en crudo, pero puede servir en an√°lisis r√°pidos.

¬øQuer√©s que te arme un comando espec√≠fico para FreePBX, Asterisk o una IP/PBX particular?








T√∫ dijiste:
ver logs de asterisk


ChatGPT Plus
Para ver los logs de Asterisk, ten√©s varias opciones dependiendo del nivel de detalle que quer√©s y qu√© tipo de logs est√°s buscando (llamadas, errores, consola, etc.).

üî∏ 1. Ver logs en tiempo real desde consola Asterisk
bash
Copiar
Editar
sudo asterisk -rvvvvv
Te conecta a la consola de Asterisk con verbosity alto (-vvvvv).

Desde ah√≠ pod√©s ver en tiempo real qu√© pasa: llamadas, registros SIP, errores, etc.

Tambi√©n pod√©s aumentar o reducir el nivel con:

bash
Copiar
Editar
core set verbose 5
core set debug 5
üî∏ 2. Ver logs en archivos (full, error, messages, etc.)
Los archivos de log de Asterisk normalmente se encuentran en:

swift
Copiar
Editar
/var/log/asterisk/
Los m√°s comunes:

/var/log/asterisk/full ‚Üí log completo (llamadas, registros, errores, etc.)

/var/log/asterisk/messages ‚Üí mensajes generales

/var/log/asterisk/debug ‚Üí si ten√©s activado el debug

/var/log/asterisk/cdr-csv/Master.csv ‚Üí registro de llamadas (CDR)

üìå Para ver en tiempo real:

bash
Copiar
Editar
sudo tail -f /var/log/asterisk/full
üî∏ 3. Activar logs si no est√°n funcionando
Asegurate de tener bien configurado el archivo de logger:

ini
Copiar
Editar
; /etc/asterisk/logger.conf
[general]
dateformat=%F %T

[logfiles]
full => notice,warning,error,debug,verbose
messages => notice,warning,error
Luego recarg√°s el logger:

bash
Copiar
Editar
sudo asterisk -rx "logger reload"
üî∏ 4. Filtrar logs por llamada espec√≠fica
Si conoc√©s el CallerID o el n√∫mero de extensi√≥n, pod√©s hacer:

bash
Copiar
Editar
grep 300 /var/log/asterisk/full
o con less:

bash
Copiar
Editar
less +F /var/log/asterisk/full
Presion√° / dentro de less y escrib√≠ el n√∫mero o t√©rmino a buscar.

¬øQuer√©s ver logs de una llamada espec√≠fica o detectar alg√∫n problema en particular (por ejemplo: fallos de registro, llamadas no completadas, etc.)? Puedo ayudarte a filtrar.








T√∫ dijiste:
estoy con el modulo bosssecretary en asterisk, esta activada la redireccion, cuando llamo al jefe me tira el mensaje "Decline" y no llama a la secretaria. Log de asterisk:
Executing [300@from-internal:6] NoOp("PJSIP/501-0000000b", "Bosssecretary: Executing module") in new stack
[2025-07-11 11:20:25] WARNING[3891][C-00000009]: pbx.c:2942 pbx_extension_helper: No application 'SIPAddHeader' for extension (from-internal, 300, 7)


ChatGPT Plus
El error que ves:

pgsql
Copiar
Editar
WARNING[3891][C-00000009]: pbx.c:2942 pbx_extension_helper: No application 'SIPAddHeader' for extension (from-internal, 300, 7)
significa que Asterisk no reconoce el comando SIPAddHeader, que es una aplicaci√≥n usada t√≠picamente para agregar encabezados SIP personalizados (muy √∫til en m√≥dulos como bosssecretary).

‚úÖ Soluci√≥n
La aplicaci√≥n SIPAddHeader no est√° disponible en canales PJSIP, solo en canales chan_sip. Y vos est√°s usando PJSIP:

Copiar
Editar
PJSIP/501-0000000b
üîÑ Alternativas para PJSIP
Cuando est√°s usando PJSIP, deb√©s usar:

asterisk
Copiar
Editar
PJSIP_HEADER(add,Header-Name)=value
En lugar de:

asterisk
Copiar
Editar
SIPAddHeader(Header-Name: value)
üîß C√≥mo adaptar tu dialplan
Revis√° el contexto que genera la redirecci√≥n del m√≥dulo bosssecretary y cambi√° la l√≠nea que dice:

asterisk
Copiar
Editar
exten => 300,n,SIPAddHeader(Diversion: <sip:secretaria@ip>;reason=unavailable)
Por:

asterisk
Copiar
Editar
exten => 300,n,Set(PJSIP_HEADER(add,Diversion)=<sip:secretaria@ip>;reason=unavailable)
üîé Asegurate de que esa l√≠nea est√© justo antes del Dial() o del Goto.

üìå Bonus: Verific√° si PJSIP_HEADER est√° disponible
Conectate a la consola de Asterisk:

bash
Copiar
Editar
sudo asterisk -rvvvvv
Y escrib√≠:

bash
Copiar
Editar
core show application PJSIP_HEADER
Deber√≠a mostrarte la documentaci√≥n si est√° cargado.

¬øQuer√©s que revise el fragmento de extensions.conf o extensions_additional.conf que genera ese error para ayudarte a editarlo correctamente? Pod√©s copiarlo y te digo qu√© reemplazar.








T√∫ dijiste:
core show application PJSIP_HEADER
Your application(s) is (are) not registered
Command 'core show application PJSIP_HEADER' failed.


ChatGPT Plus
Gracias por confirmarlo. El error:

java
Copiar
Editar
Your application(s) is (are) not registered
Command 'core show application PJSIP_HEADER' failed.
indica que PJSIP_HEADER no es una application, sino una funci√≥n de canal.

‚úÖ Forma correcta de consultarlo
Us√°:

bash
Copiar
Editar
core show function PJSIP_HEADER
Y deber√≠as ver algo como:

csharp
Copiar
Editar
  -= Info about function 'PJSIP_HEADER' =-

[Syntax]
PJSIP_HEADER(read|remove,name[,index])
PJSIP_HEADER(add,name)=value
...
Esto confirma que pod√©s usarla con Set() en el dialplan.

üîß C√≥mo usarlo en tu extensions.conf o c√≥digo del m√≥dulo
Reemplaz√°:

asterisk
Copiar
Editar
same => n,SIPAddHeader(Diversion: <sip:secretaria@ip>;reason=unavailable)
Por:

asterisk
Copiar
Editar
same => n,Set(PJSIP_HEADER(add,Diversion)=<sip:secretaria@ip>;reason=unavailable)
‚ö†Ô∏è Esto solo funciona si el canal que realiza la llamada es PJSIP. No uses SIPAddHeader con PJSIP.

Si quer√©s, peg√° el contexto que est√°s usando para bosssecretary y te doy el reemplazo exacto.








T√∫ dijiste:
[ext-bosssecretary]
include => ext-bosssecretary-custom
include => app-bosssecretary-toggle
include => app-bosssecretary-on
include => app-bosssecretary-off
include => app-bosssecretary-hints
exten => 300,1,Noop(Bosssecretary: Checking  lock for 300 extension)
exten => 300,n,Gosub(macro-user-callerid,s,1())
exten => 300,n,Set(CALLER=${CALLERID(num)})
exten => 300,n,GotoIf(${DB_EXISTS(bosssecretary/group/1/member/${CALLER})}?exit_module)
exten => 300,n,GotoIf(${DB_EXISTS(bosssecretary/group/1/locked)}?exit_module:run_module)
exten => 300,n(run_module),Noop(Bosssecretary: Executing module)
exten => 300,n,SIPAddHeader(Alert-Info: <http://nohost>\;info=alert-group\;x-line-id=0)
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))
exten => 300,n(exit_module),Noop(Bosssecretary: Exit)
exten => 300,n,Goto(ext-local,300,1)

;--== end of [ext-bosssecretary] ==--;


ChatGPT Plus
Gracias por compartir tu contexto ext-bosssecretary. Como est√°s usando PJSIP (seg√∫n tu log: PJSIP/501-0000000b), el uso de SIPAddHeader es incorrecto, ya que no tiene efecto con canales PJSIP y de hecho genera el error que ves.

‚úÖ Versi√≥n corregida del contexto
Reemplaz√° esta l√≠nea:

asterisk
Copiar
Editar
exten => 300,n,SIPAddHeader(Alert-Info: <http://nohost>\;info=alert-group\;x-line-id=0)
Por esta otra:

asterisk
Copiar
Editar
exten => 300,n,Set(PJSIP_HEADER(add,Alert-Info)=<http://nohost>\;info=alert-group\;x-line-id=0)
üîç Contexto completo corregido
asterisk
Copiar
Editar
[ext-bosssecretary]
include => ext-bosssecretary-custom
include => app-bosssecretary-toggle
include => app-bosssecretary-on
include => app-bosssecretary-off
include => app-bosssecretary-hints

exten => 300,1,Noop(Bosssecretary: Checking  lock for 300 extension)
exten => 300,n,Gosub(macro-user-callerid,s,1())
exten => 300,n,Set(CALLER=${CALLERID(num)})
exten => 300,n,GotoIf(${DB_EXISTS(bosssecretary/group/1/member/${CALLER})}?exit_module)
exten => 300,n,GotoIf(${DB_EXISTS(bosssecretary/group/1/locked)}?exit_module:run_module)
exten => 300,n(run_module),Noop(Bosssecretary: Executing module)
exten => 300,n,Set(PJSIP_HEADER(add,Alert-Info)=<http://nohost>\;info=alert-group\;x-line-id=0)
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))
exten => 300,n(exit_module),Noop(Bosssecretary: Exit)
exten => 300,n,Goto(ext-local,300,1)
üìå Notas adicionales
Si m√°s adelante quer√©s agregar otros encabezados SIP personalizados (como Diversion), hacelo tambi√©n con PJSIP_HEADER.

Asegurate de que la extensi√≥n 301 (la secretaria) est√© registrada y disponible, y que tenga permiso de ser llamada desde esta l√≥gica.

Si us√°s Dial() directamente en lugar de macro-dial, pod√©s agregar el encabezado justo antes del Dial() como en:

asterisk
Copiar
Editar
Set(PJSIP_HEADER(add,Diversion)=<sip:301@yourdomain>;reason=unavailable)
¬øQuer√©s que revise tambi√©n el destino final de macro-dial para confirmar que efectivamente llama a la secretaria si el jefe no est√° disponible?








T√∫ dijiste:
correg√≠ eso y ahora me tira:
    -- Executing [s@macro-dial:31] Gosub("PJSIP/501-0000000e", "dial-with-exten,,1()") in new stack
[2025-07-11 11:31:47] ERROR[5162][C-0000000c]: app_stack.c:616 gosub_exec: Gosub attempted to reach non-existent destination 'dial-with-exten,s,1' from 'macro-dial,s,31'

sin embargo parece que hace la redireccion por lo que vi en logs anteriores


ChatGPT Plus
Ese error:

css
Copiar
Editar
ERROR[5162][C-0000000c]: app_stack.c:616 gosub_exec: Gosub attempted to reach non-existent destination 'dial-with-exten,s,1' from 'macro-dial,s,31'
significa que Asterisk est√° intentando ejecutar:

scss
Copiar
Editar
Gosub(dial-with-exten,s,1)
pero no existe el contexto dial-with-exten con la extensi√≥n s.

üîé Por qu√© pasa esto
Esto ocurre porque alg√∫n lugar del contexto macro-dial (que vos est√°s llamando con esta l√≠nea):

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))
...intenta invocar un contexto dial-with-exten que no est√° definido.

Es probable que:

Est√©s usando una versi√≥n de FreePBX o Asterisk donde macro-dial asume que existe dial-with-exten.

Alg√∫n hook o modificaci√≥n del m√≥dulo bosssecretary provoca eso.

A pesar del error, la llamada contin√∫a porque no era cr√≠tica.

‚úÖ Soluciones posibles
‚úÖ Opci√≥n 1: Crear un contexto vac√≠o para evitar el error
Agreg√° este contexto en un archivo de dialplan (por ejemplo, extensions_custom.conf):

asterisk
Copiar
Editar
[dial-with-exten]
exten => s,1,Return()
Esto evita el error y no afecta el comportamiento (es un "stub").

‚úÖ Opci√≥n 2: Verific√° si tu FreePBX ya tiene el contexto
Pod√©s revisar si existe en consola con:

bash
Copiar
Editar
dialplan show dial-with-exten
Si no aparece, entonces no existe y deber√≠as usar la opci√≥n anterior.

‚úÖ Opci√≥n 3: Usar directamente Dial() (si quer√©s evitar macro-dial)
Si no depend√©s de macro-dial, pod√©s hacer algo como:

asterisk
Copiar
Editar
exten => 300,n,Dial(PJSIP/301,${RINGTIMER},${DIAL_OPTIONS})
Pero FreePBX usa macro-dial por varias razones (grabaci√≥n, CDR, etc.), as√≠ que solo hacelo si sab√©s que no depend√©s de su l√≥gica.

üß† Recomendaci√≥n
Agreg√° el contexto dial-with-exten vac√≠o como se muestra arriba. Es la forma segura y no invasiva de resolver ese error sin romper nada m√°s en FreePBX.

¬øQuer√©s que lo armemos completo en un extensions_custom.conf y lo incluyas desde tu m√≥dulo?








T√∫ dijiste:
dialplan show dial-with-exten
[ Context 'dial-with-exten' created by 'pbx_config' ]
  '_X.' =>          1. Dial(${ds}${CWRING}b(func-apply-sipheaders^s^1),) [extensions_additional.conf:3164]
                    2. Return()                                   [extensions_additional.conf:3165]
  '_X' =>           1. Dial(${ds}${CWRING}b(func-apply-sipheaders^s^1),) [extensions_additional.conf:3167]
                    2. Return()                                   [extensions_additional.conf:3168]
  Include =>        'dial-with-exten-custom'                      [pbx_config]

-= 2 extensions (4 priorities) in 1 context. =-


ChatGPT Plus
Perfecto, gracias por ese output.

Significa que el contexto dial-with-exten s√≠ existe, pero no tiene definida la extensi√≥n s, que es la que se est√° intentando invocar:

arduino
Copiar
Editar
Gosub("PJSIP/501-0000000e", "dial-with-exten,,1()")
üîç ¬øQu√© est√° mal?
Tu Gosub() intenta llamar a:

csharp
Copiar
Editar
dial-with-exten, s, 1
Pero ese contexto solo tiene definidas las extensiones:

_X.

_X

No tiene s.

‚úÖ Soluci√≥n recomendada
Agreg√° una extensi√≥n s gen√©rica en el contexto dial-with-exten-custom, que es un include pensado para sobreescribir o ampliar dial-with-exten.

üìÅ Archivo: /etc/asterisk/extensions_custom.conf
Agreg√°:

asterisk
Copiar
Editar
[dial-with-exten-custom]
exten => s,1,Return()
‚úÖ Luego recarg√° el dialplan:
bash
Copiar
Editar
sudo asterisk -rx "dialplan reload"
üéØ Resultado
Con eso, Asterisk va a encontrar la extensi√≥n s en el contexto dial-with-exten, evitar√° el error:

nginx
Copiar
Editar
Gosub attempted to reach non-existent destination 'dial-with-exten,s,1'
Y todo seguir√° funcionando normalmente, ya que este Gosub() probablemente es opcional.

¬øQuer√©s que tambi√©n revise qu√© hace func-apply-sipheaders o si se necesita agregar un encabezado adicional como parte del m√≥dulo?








T√∫ dijiste:
ahora llama directo a mi jefe, yo quiero que redirija a mi secretaria


ChatGPT Plus
Perfecto, eso aclara mucho. Si al llamar al jefe (extensi√≥n 300) te atiende directamente el jefe, significa que la l√≥gica del m√≥dulo bosssecretary est√° salt√°ndose la redirecci√≥n hacia la secretaria (301) y est√° ejecutando la √∫ltima l√≠nea:

asterisk
Copiar
Editar
exten => 300,n,Goto(ext-local,300,1)
üß© ¬øQu√© deber√≠a hacer?
Vamos a revisar la l√≥gica actual que ten√©s:

asterisk
Copiar
Editar
exten => 300,n,GotoIf(${DB_EXISTS(bosssecretary/group/1/member/${CALLER})}?exit_module)
exten => 300,n,GotoIf(${DB_EXISTS(bosssecretary/group/1/locked)}?exit_module:run_module)
Esto dice:

Si el que llama est√° registrado como "miembro" (probablemente el jefe o alg√∫n privilegiado) ‚Üí salta al exit_module y llama al jefe directo.

Si el grupo est√° "locked" (bloqueado), tambi√©n salta al exit_module.

Luego:

asterisk
Copiar
Editar
exten => 300,n(run_module),Noop(Bosssecretary: Executing module)
exten => 300,n,Set(PJSIP_HEADER(...))  ; (esto es donde agreg√°s encabezados)
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))
Y finalmente, en exit_module:

asterisk
Copiar
Editar
exten => 300,n(exit_module),Noop(Bosssecretary: Exit)
exten => 300,n,Goto(ext-local,300,1)  ; llama al jefe directamente
‚úÖ Soluci√≥n: forzar que redirija a la secretaria
Si quer√©s que todas las llamadas (excepto las de la secretaria o el jefe mismo) sean redirigidas a la secretaria, revisemos:

¬øQu√© contiene bosssecretary/group/1/member/XXX en la base de datos interna?

¬øQui√©n est√° definido como ‚Äúlocked‚Äù o no?

üîß Opci√≥n simple: ignorar el salto a exit_module (para testeo)
Coment√° o elimin√° moment√°neamente esta l√≠nea:

asterisk
Copiar
Editar
exten => 300,n,Goto(ext-local,300,1)
Y forz√° que siempre llame a la secretaria para probar:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))
‚úÖ Opci√≥n m√°s elegante: invertir la l√≥gica
Cambiala para que redirija a la secretaria si el jefe est√° "ocupado" o "modo secretaria activado".

Por ejemplo:

asterisk
Copiar
Editar
exten => 300,1,Noop(Bosssecretary: Checking lock for 300)
exten => 300,n,Gosub(macro-user-callerid,s,1())
exten => 300,n,Set(CALLER=${CALLERID(num)})

; Si el que llama ES el jefe o la secretaria, dejar pasar
exten => 300,n,GotoIf($["${CALLER}" = "301"]?exit_module)
exten => 300,n,GotoIf($["${CALLER}" = "300"]?exit_module)

; Si est√° en modo secretaria, redirigir
exten => 300,n,GotoIf(${DB_EXISTS(bosssecretary/group/1/locked)}?run_module:exit_module)

exten => 300,n(run_module),Noop(Bosssecretary: Ejecutando redirecci√≥n a secretaria)
exten => 300,n,Set(PJSIP_HEADER(add,Alert-Info)=<http://nohost>\;info=alert-group\;x-line-id=0)
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))

exten => 300,n(exit_module),Noop(Bosssecretary: Llamando directamente al jefe)
exten => 300,n,Goto(ext-local,300,1)
üß™ Pod√©s revisar el estado de la DB interna de Asterisk as√≠:
bash
Copiar
Editar
asterisk -rx "database show bosssecretary"
Y vas a ver cosas como:

bash
Copiar
Editar
/bosssecretary/group/1/locked             : 1
/bosssecretary/group/1/member/501         : 1
Pod√©s borrarlos para pruebas con:

bash
Copiar
Editar
asterisk -rx "database deltree bosssecretary"
¬øQuer√©s que prepare un ejemplo completo de l√≥gica que redirija siempre a la secretaria si el modo secretaria est√° activado?


2/2








T√∫ dijiste:
 Executing [300@from-internal:6] NoOp("PJSIP/501-00000017", "Bosssecretary: Executing module") in new stack
    -- Executing [300@from-internal:7] Set("PJSIP/501-00000017", "PJSIP_HEADER(add,Alert-Info)=<http://nohost>;info=alert-group;x-line-id=0") in new stack
    -- Executing [300@from-internal:8] Gosub("PJSIP/501-00000017", "macro-dial,s,1(,HhTtr,301)") in new stack
    -- Executing [s@macro-dial:1] NoOp("PJSIP/501-00000017", "Blind Transfer: , Attended Transfer: , User: 501, Alert Info: ") in new stack
    -- Executing [s@macro-dial:2] Set("PJSIP/501-00000017", "__CRM_SOURCE=501") in new stack
    -- Executing [s@macro-dial:3] ExecIf("PJSIP/501-00000017", "1?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:4] ExecIf("PJSIP/501-00000017", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:5] ExecIf("PJSIP/501-00000017", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:6] ExecIf("PJSIP/501-00000017", "0?Set(CHANNEL(musicclass)=)") in new stack
    -- Executing [s@macro-dial:7] AGI("PJSIP/501-00000017", "agi://127.0.0.1/dialparties.agi") in new stack
 agi://127.0.0.1/dialparties.agi: Starting New Dialparties.agi
 agi://127.0.0.1/dialparties.agi: Caller ID name is '501' number is '501'
 agi://127.0.0.1/dialparties.agi: CW Ignore is:
 agi://127.0.0.1/dialparties.agi: CF Ignore is:
 agi://127.0.0.1/dialparties.agi: CW IN_USE/BUSY is: 1
 agi://127.0.0.1/dialparties.agi: Ringgroup confirm is  :
        > agi://127.0.0.1/dialparties.agi: USE_CONFIRMATION:  'FALSE'
        > agi://127.0.0.1/dialparties.agi: RINGGROUP_INDEX:   ''
 agi://127.0.0.1/dialparties.agi: Methodology of ring is  'none'
    -- agi://127.0.0.1/dialparties.agi: Added extension 301 to extension map
    -- agi://127.0.0.1/dialparties.agi: Extension 301 cf is disabled
    -- agi://127.0.0.1/dialparties.agi: Extension 301 do not disturb is disabled
       > agi://127.0.0.1/dialparties.agi: extnum 301 has:  cw: 1; hascfb: 0 [] hascfu: 0 []
 agi://127.0.0.1/dialparties.agi: EXTENSION_STATE: 0 (NOT_INUSE)
  == agi://127.0.0.1/dialparties.agi: Discovered PJSIP Endpoint PJSIP/301
    -- agi://127.0.0.1/dialparties.agi: Ended up with real PJSIP Dial string PJSIP/301/sip:301@10.1.2.168:63086;ob
    -- agi://127.0.0.1/dialparties.agi: dbset CALLTRACE/301 to 501
    -- agi://127.0.0.1/dialparties.agi: Filtered ARG3: 301
 agi://127.0.0.1/dialparties.agi: RVOL_MODE ''
 agi://127.0.0.1/dialparties.agi: RVOL is:
 agi://127.0.0.1/dialparties.agi: RVOLPARENT is:
    -- <PJSIP/501-00000017>AGI Script agi://127.0.0.1/dialparties.agi completed, returning 0


ChatGPT Plus
Gracias por compartir los logs. Lo que veo en tu salida indica que la redirecci√≥n a la secretaria (extensi√≥n 301) est√° funcionando correctamente, y que la llamada se est√° enviando a:

bash
Copiar
Editar
PJSIP/301/sip:301@10.1.2.168:63086;ob
Eso significa que Asterisk est√° intentando contactar a la secretaria como lo esper√°s. No est√° llamando al jefe directamente, y por lo tanto la l√≥gica de bosssecretary est√° funcionando.

üü¢ Estado actual
‚úÖ Llam√°s al 300 ‚Üí entra al m√≥dulo bosssecretary

‚úÖ Se eval√∫a que est√° en modo secretaria (locked)

‚úÖ La l√≥gica macro-dial es invocada con destino 301

‚úÖ Se genera correctamente el dial string PJSIP/301/...

‚úÖ No hay errores visibles

üß™ ¬øQu√© puede estar faltando?
Si no suena el tel√©fono de la secretaria o la llamada no completa, las causas probables son:

üî∏ 1. Problema en el dispositivo de la secretaria (301)
¬øEst√° registrada?

¬øEst√° en la red correcta?

¬øTiene habilitada la opci√≥n ‚ÄúNo molestar‚Äù (DND)?

¬øEl softphone o tel√©fono IP est√° funcionando?

Verific√° desde consola:

bash
Copiar
Editar
asterisk -rx "pjsip show endpoint 301"
Y confirm√° que diga algo como:

makefile
Copiar
Editar
Status: Available
...
Contact: sip:301@10.1.2.168:63086;ob
üî∏ 2. Fallo en la red/RTP/audio
¬øTen√©s audio entre llamador y secretaria?

¬øEst√°s usando NAT correctamente?

¬øLos puertos UDP para RTP est√°n abiertos?

Verific√° en Wireshark o consola si se est√°n negociando correctamente los medios.

üî∏ 3. El tel√©fono 301 no contesta (pero s√≠ suena)
En ese caso, el sistema hizo su parte. Pod√©s verificar en el log si aparece:

diff
Copiar
Editar
-- Called PJSIP/301/...
-- Ringing
Si no ves ‚ÄúRinging‚Äù, puede que el dispositivo est√© rechazando la llamada (por ejemplo, est√© en estado busy, DND, etc.).

‚úÖ Pr√≥ximo paso
Ejecut√° esto para confirmar si Asterisk ve el dispositivo como disponible:

bash
Copiar
Editar
asterisk -rx "pjsip show contacts"
Busc√° la l√≠nea de 301. Si no est√° en estado Avail, ah√≠ est√° el problema.

¬øQuer√©s que prepare una l√≥gica para que, si 301 no contesta, reintente con el jefe o con un buz√≥n de voz? ¬øO quer√©s que depuremos la conexi√≥n SIP con el dispositivo 301?








T√∫ dijiste:
    -- Executing [s@macro-dial:30] ExecIf("PJSIP/501-0000001c", "0?Set(ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,,HhTtrg)") in new stack
    -- Executing [s@macro-dial:31] Gosub("PJSIP/501-0000001c", "dial-with-exten,,1()") in new stack
    -- Executing [s@dial-with-exten:1] Return("PJSIP/501-0000001c", "") in new stack
    -- Executing [s@macro-dial:32] Set("PJSIP/501-0000001c", "DIALSTATUS=") in new stack
    -- Executing [s@macro-dial:33] GosubIf("PJSIP/501-0000001c", "0?,1()") in new stack
    -- Executing [s@macro-dial:34] NoOp("PJSIP/501-0000001c", "Returning since nobody answered") in new stack
    -- Executing [s@macro-dial:35] Return("PJSIP/501-0000001c", "") in new stack
    -- Executing [300@from-internal:9] NoOp("PJSIP/501-0000001c", "Bosssecretary: Exit") in new stack
    -- Executing [300@from-internal:10] Goto("PJSIP/501-0000001c", "ext-local,300,1") in new stack


el 301 est√° disponible


ChatGPT Plus
Gracias por compartir ese fragmento: el log es claro y apunta a lo siguiente:

‚ö†Ô∏è El m√≥dulo est√° intentando llamar a la secretaria (301), pero no se est√° realizando la llamada
En particular, estas dos l√≠neas son la clave:

typescript
Copiar
Editar
-- Executing [s@macro-dial:30] ExecIf("PJSIP/501-0000001c", "0?Set(ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,,HhTtrg)") in new stack
-- Executing [s@macro-dial:32] Set("PJSIP/501-0000001c", "DIALSTATUS=") in new stack
Esto nos dice:

Asterisk descubri√≥ el endpoint de la secretaria (sip:301@10.1.2.168:63086) pero no asign√≥ el canal de destino (ds), porque la condici√≥n ExecIf(...) evalu√≥ falso (0?Set(...)).

Por lo tanto, no hay canal al que marcar, y DIALSTATUS queda vac√≠o.

Luego, cae en esta l√≠nea:

graphql
Copiar
Editar
-- Executing [s@macro-dial:34] NoOp("PJSIP/501-0000001c", "Returning since nobody answered")
¬°Pero en realidad ni siquiera intent√≥ marcar!

‚úÖ Diagn√≥stico: macro-dial no recibi√≥ bien el tercer argumento (el n√∫mero a marcar)
Tu l√≠nea:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))
Pasa argumentos a macro-dial, y este los usa as√≠:

ini
Copiar
Editar
ARG1 = ringtimer
ARG2 = options
ARG3 = EXTENSION A LLAMAR
El log indica que ARG3 est√° llegando vac√≠o o malformado.

‚úÖ Soluci√≥n
Verific√° que las variables ${RINGTIMER} y ${DIAL_OPTIONS} est√©n definidas antes del Gosub.

Si quer√©s hacer una prueba r√°pida y forzar el valor fijo, hac√© as√≠:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301))
20 segundos de ring

HhTtr son las opciones est√°ndar

301 es el interno de la secretaria

üìå Si eso funciona, entonces el problema est√° en que:
${RINGTIMER} est√° vac√≠o

${DIAL_OPTIONS} est√° vac√≠o o malformado

O alguna coma mal escapada en los argumentos

Pod√©s debuguear los valores antes de hacer el Gosub:

asterisk
Copiar
Editar
exten => 300,n,NoOp(RINGTIMER=${RINGTIMER}, DIAL_OPTIONS=${DIAL_OPTIONS})
¬øQuer√©s que te arme una versi√≥n completa con defaults seguros si las variables est√°n vac√≠as?








T√∫ dijiste:
   -- Executing [300@from-internal:6] NoOp("PJSIP/501-00000027", "Bosssecretary: Executing module") in new stack
    -- Executing [300@from-internal:7] Set("PJSIP/501-00000027", "PJSIP_HEADER(add,Alert-Info)=<http://nohost>;info=alert-group;x-line-id=0") in new stack
    -- Executing [300@from-internal:8] NoOp("PJSIP/501-00000027", "RINGTIMER=, DIAL_OPTIONS=HhTtr") in new stack
    -- Executing [300@from-internal:9] Gosub("PJSIP/501-00000027", "macro-dial,s,1(20,HhTtr,301)") in new stack

harcode√© el ring timer en gosub


ChatGPT Plus
¬°Perfecto! Ahora s√≠ estamos en buen camino.

La l√≠nea:

kotlin
Copiar
Editar
-- Executing [300@from-internal:8] NoOp("PJSIP/501-00000027", "RINGTIMER=, DIAL_OPTIONS=HhTtr")
confirma que:

${RINGTIMER} estaba vac√≠o

${DIAL_OPTIONS} ten√≠a el valor esperado: HhTtr

‚úÖ Estado actual
Con tu l√≠nea:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301))
ahora el dialplan est√° llamando correctamente a la secretaria con:

Un ring timer expl√≠cito (20 segundos)

Las opciones adecuadas

El n√∫mero correcto

üéØ Recomendaci√≥n final
Si quer√©s hacerlo m√°s robusto y no depender de variables que pueden estar vac√≠as, pod√©s usar valores por defecto con l√≥gica como esta:

asterisk
Copiar
Editar
exten => 300,n,Set(RINGTIMER=${IF($[${ISNULL(${RINGTIMER})}]?20:${RINGTIMER})})
exten => 300,n,Set(DIAL_OPTIONS=${IF($[${ISNULL(${DIAL_OPTIONS})}]?HhTtr:${DIAL_OPTIONS})})
exten => 300,n,NoOp(RINGTIMER=${RINGTIMER}, DIAL_OPTIONS=${DIAL_OPTIONS})
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))
As√≠ te asegur√°s de que nunca pasen valores vac√≠os a macro-dial.

¬øQuer√©s que revise si pod√©s controlar el desv√≠o hacia la secretaria seg√∫n un bot√≥n (feature code) o un estado din√°mico (por ejemplo, un *71 para activar y *72 para desactivar)?








T√∫ dijiste:
pero sigue llamando directamente al 300


ChatGPT Plus
Gracias por el seguimiento. Si a pesar de que el macro-dial se invoca con el n√∫mero 301, termina llamando igual al 300, es muy probable que el problema est√© en c√≥mo FreePBX maneja internamente el macro-dial y el dialparties.agi, que puede estar ignorando el n√∫mero que le pas√°s y tomando el valor desde la base de datos de destinos del ext-local.

üîç Diagn√≥stico paso a paso
Tu log muestra:

arduino
Copiar
Editar
Gosub("PJSIP/501-00000027", "macro-dial,s,1(20,HhTtr,301)")
Y a√∫n as√≠:

vbnet
Copiar
Editar
Goto("PJSIP/501-00000027", "ext-local,300,1")
al final termina llamando al jefe (300).

Eso significa que la llamada a la secretaria (301) no se realiz√≥ o no se consider√≥ exitosa, y por eso el flujo contin√∫a al bloque exit_module, el cual hace:

asterisk
Copiar
Editar
Goto(ext-local,300,1)
üîß Soluci√≥n recomendada: prevenir que vuelva a llamar al jefe
Hay dos caminos:

‚úÖ OPCI√ìN 1: DETENER el flujo si ya se llam√≥ a la secretaria
Modific√° el bloque run_module as√≠:

asterisk
Copiar
Editar
exten => 300,n(run_module),Noop(Bosssecretary: Ejecutando m√≥dulo)
exten => 300,n,Set(PJSIP_HEADER(add,Alert-Info)=<http://nohost>\;info=alert-group\;x-line-id=0)
exten => 300,n,Set(RINGTIMER=20)
exten => 300,n,Set(DIAL_OPTIONS=HhTtr)
exten => 300,n,Gosub(macro-dial,s,1(${RINGTIMER},${DIAL_OPTIONS},301))
exten => 300,n,Hangup()
Con eso, si la secretaria no atiende, se cuelga la llamada en lugar de seguir a:

asterisk
Copiar
Editar
exten => 300,n(exit_module),Goto(ext-local,300,1)
‚úÖ OPCI√ìN 2: Solo permitir que el jefe o la secretaria salten el m√≥dulo
Revis√° si esta l√≥gica se cumple:

asterisk
Copiar
Editar
exten => 300,n,GotoIf($["${CALLER}" = "301"]?exit_module)
exten => 300,n,GotoIf($["${CALLER}" = "300"]?exit_module)
Todos los dem√°s deber√≠an ejecutar el bloque run_module.

‚úÖ Alternativa m√°s limpia: usar Return() y aislar el salto
Cambi√° el bloque exit_module as√≠:

asterisk
Copiar
Editar
exten => 300,n(exit_module),NoOp(Bosssecretary: Exit - no redirecci√≥n)
exten => 300,n,Return()
Y mov√© la llamada directa al jefe fuera del m√≥dulo, por ejemplo, al contexto ext-local.

üîö En resumen
üîß Lo que est√° pasando:

El m√≥dulo intenta llamar a 301 (secretaria), pero cuando no responde o se considera que nadie atendi√≥, sigue el dialplan y cae en la llamada directa al 300.

‚úÖ Lo que pod√©s hacer:

Agregar un Hangup() o Return() despu√©s del macro-dial a 301.

Controlar expl√≠citamente el flujo para evitar que se vuelva al jefe.

¬øQuer√©s que te prepare el m√≥dulo bosssecretary con control completo para:

Activar/desactivar modo secretaria

Derivar llamadas solo si el modo est√° activado

Detener el flujo si no atiende la secretaria?

Puedo darte un ejemplo completo.








T√∫ dijiste:
ahora cuelga pero no llama a la secretaria, el cual es el problema


ChatGPT Plus
Gracias por la aclaraci√≥n. Si el flujo ahora cuelga pero nunca llega a llamar realmente a la secretaria (301), a pesar de que el log dice que invoc√°s:

scss
Copiar
Editar
Gosub(macro-dial,s,1(20,HhTtr,301))
‚Ä¶pero no hay rastro en los logs de que intente realmente marcar a 301, el problema m√°s probable est√° en c√≥mo se construye la variable ds dentro del macro-dial, y qu√© pasa en el AGI dialparties.agi.

üß† ¬øQu√© pasa dentro de macro-dial?
FreePBX invoca internamente el script AGI dialparties.agi, que:

Toma el argumento 3 (ARG3 = 301)

Valida si el interno est√° disponible

Construye la variable ds (el string de marcaci√≥n real)

Y si todo est√° bien, ejecuta el Dial(${ds})

El problema est√° en esta l√≠nea de tu log:

cpp
Copiar
Editar
-- Executing [s@macro-dial:30] ExecIf("PJSIP/501-0000001c", "0?Set(ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,,HhTtrg)") in new stack
‚ùó El ExecIf eval√∫a a 0 (falso), entonces NO se setea ds, y por eso no se marca a nadie.

‚úÖ Soluci√≥n concreta: pasar el n√∫mero como lista (con @ o separados por -)
El macro-dial de FreePBX espera el argumento 3 (ARG3) como una lista de internos v√°lidos, no simplemente 301.

üîß En lugar de:
asterisk
Copiar
Editar
Gosub(macro-dial,s,1(20,HhTtr,301))
‚úÖ Us√° esto:
asterisk
Copiar
Editar
Gosub(macro-dial,s,1(20,HhTtr,301@from-internal))
O si est√°s seguro de que no us√°s contextos personalizados:

asterisk
Copiar
Editar
Gosub(macro-dial,s,1(20,HhTtr,301-))
El - al final es importante, FreePBX lo interpreta como separaci√≥n de internos (aunque solo haya uno).

Tambi√©n pod√©s probar con 301@from-internal, que fuerza el contexto.

üß™ Opcional: Verific√° que el 301 est√© en un ring group
Pod√©s probar esto desde consola para asegurarte de que el interno 301 responde correctamente:

bash
Copiar
Editar
channel originate PJSIP/301 application Playback hello-world
Si no suena, hay un problema de red o NAT.

‚úÖ Resumen final de soluci√≥n sugerida
En tu contexto ext-bosssecretary, cambi√°:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301))
por:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301-))
o

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301@from-internal))
¬øQuer√©s que te d√© una versi√≥n completa del contexto con l√≥gica m√°s robusta (activaci√≥n/desactivaci√≥n + logueo + fallback)?








T√∫ dijiste:
 -- Executing [300@from-internal:6] NoOp("PJSIP/501-0000002b", "Bosssecretary: Executing module") in new stack
    -- Executing [300@from-internal:7] Set("PJSIP/501-0000002b", "PJSIP_HEADER(add,Alert-Info)=<http://nohost>;info=alert-group;x-line-id=0") in new stack
    -- Executing [300@from-internal:8] NoOp("PJSIP/501-0000002b", "RINGTIMER=, DIAL_OPTIONS=HhTtr") in new stack
    -- Executing [300@from-internal:9] Gosub("PJSIP/501-0000002b", "macro-dial,s,1(20,HhTtr,301)") in new stack
    -- Executing [s@macro-dial:1] NoOp("PJSIP/501-0000002b", "Blind Transfer: , Attended Transfer: , User: 501, Alert Info: ") in new stack
    -- Executing [s@macro-dial:2] Set("PJSIP/501-0000002b", "__CRM_SOURCE=501") in new stack
    -- Executing [s@macro-dial:3] ExecIf("PJSIP/501-0000002b", "1?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:4] ExecIf("PJSIP/501-0000002b", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:5] ExecIf("PJSIP/501-0000002b", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:6] ExecIf("PJSIP/501-0000002b", "0?Set(CHANNEL(musicclass)=)") in new stack
    -- Executing [s@macro-dial:7] AGI("PJSIP/501-0000002b", "agi://127.0.0.1/dialparties.agi") in new stack
 agi://127.0.0.1/dialparties.agi: Starting New Dialparties.agi
 agi://127.0.0.1/dialparties.agi: Caller ID name is '501' number is '501'
 agi://127.0.0.1/dialparties.agi: CW Ignore is:
 agi://127.0.0.1/dialparties.agi: CF Ignore is:
 agi://127.0.0.1/dialparties.agi: CW IN_USE/BUSY is: 1
 agi://127.0.0.1/dialparties.agi: Ringgroup confirm is  :
        > agi://127.0.0.1/dialparties.agi: USE_CONFIRMATION:  'FALSE'
        > agi://127.0.0.1/dialparties.agi: RINGGROUP_INDEX:   ''
 agi://127.0.0.1/dialparties.agi: Methodology of ring is  'none'
    -- agi://127.0.0.1/dialparties.agi: Added extension 301 to extension map
    -- agi://127.0.0.1/dialparties.agi: Extension 301 cf is disabled
    -- agi://127.0.0.1/dialparties.agi: Extension 301 do not disturb is disabled
       > agi://127.0.0.1/dialparties.agi: extnum 301 has:  cw: 1; hascfb: 0 [] hascfu: 0 []
 agi://127.0.0.1/dialparties.agi: EXTENSION_STATE: 0 (NOT_INUSE)
  == agi://127.0.0.1/dialparties.agi: Discovered PJSIP Endpoint PJSIP/301
    -- agi://127.0.0.1/dialparties.agi: Ended up with real PJSIP Dial string PJSIP/301/sip:301@10.1.2.168:63086;ob
    -- agi://127.0.0.1/dialparties.agi: dbset CALLTRACE/301 to 501
    -- agi://127.0.0.1/dialparties.agi: Filtered ARG3: 301
 agi://127.0.0.1/dialparties.agi: RVOL_MODE ''
 agi://127.0.0.1/dialparties.agi: RVOL is:
 agi://127.0.0.1/dialparties.agi: RVOLPARENT is:
    -- <PJSIP/501-0000002b>AGI Script agi://127.0.0.1/dialparties.agi completed, returning 0
    -- Executing [s@macro-dial:8] GotoIf("PJSIP/501-0000002b", "1?normdial") in new stack
    -- Goto (macro-dial,s,11)
    -- Executing [s@macro-dial:11] NoOp("PJSIP/501-0000002b", "Returned from dialparties with groups to dial") in new stack
    -- Executing [s@macro-dial:12] NoOp("PJSIP/501-0000002b", "ringall array  ") in new stack
    -- Executing [s@macro-dial:13] NoOp("PJSIP/501-0000002b", "ds= PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr ") in new stack
    -- Executing [s@macro-dial:14] NoOp("PJSIP/501-0000002b", "dsextra= ") in new stack
    -- Executing [s@macro-dial:15] Set("PJSIP/501-0000002b", "ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr") in new stack
    -- Executing [s@macro-dial:16] NoOp("PJSIP/501-0000002b", "ds= PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr") in new stack
    -- Executing [s@macro-dial:17] Set("PJSIP/501-0000002b", "__FMGL_DIAL=") in new stack
    -- Executing [s@macro-dial:18] Set("PJSIP/501-0000002b", "LOOPCNT=1") in new stack
    -- Executing [s@macro-dial:19] Set("PJSIP/501-0000002b", "ITER=1") in new stack
    -- Executing [s@macro-dial:20] Set("PJSIP/501-0000002b", "__EXTTOCALL=301") in new stack
    -- Executing [s@macro-dial:21] Set("PJSIP/501-0000002b", "__MCEXTTOCALL=301") in new stack
    -- Executing [s@macro-dial:22] NoOp("PJSIP/501-0000002b", "Working with 301") in new stack
    -- Executing [s@macro-dial:23] ExecIf("PJSIP/501-0000002b", "0?Set(HASH(__SIPHEADERS,Alert-Info)=Normal;volume=)") in new stack
    -- Executing [s@macro-dial:24] ExecIf("PJSIP/501-0000002b", "0?Set(HASH(__SIPHEADERS,Alert-Info)=Normal;volume=)") in new stack
    -- Executing [s@macro-dial:25] Set("PJSIP/501-0000002b", "ITER=2") in new stack
    -- Executing [s@macro-dial:26] GotoIf("PJSIP/501-0000002b", "0?ndloopbegin") in new stack
    -- Executing [s@macro-dial:27] Gosub("PJSIP/501-0000002b", "macro-dial-ringall-predial-hook,s,1()") in new stack
    -- Executing [s@macro-dial-ringall-predial-hook:1] Return("PJSIP/501-0000002b", "") in new stack
    -- Executing [s@macro-dial:28] ExecIf("PJSIP/501-0000002b", "0?Set(CWRING=r(callwaiting)):Set(CWRING=)") in new stack
    -- Executing [s@macro-dial:29] ExecIf("PJSIP/501-0000002b", "0?Set(RGFMDIAL=301):Set(RGFMDIAL=)") in new stack
    -- Executing [s@macro-dial:30] ExecIf("PJSIP/501-0000002b", "0?Set(ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtrg)") in new stack
    -- Executing [s@macro-dial:31] Gosub("PJSIP/501-0000002b", "dial-with-exten,,1()") in new stack
    -- Executing [s@dial-with-exten:1] Return("PJSIP/501-0000002b", "") in new stack
    -- Executing [s@macro-dial:32] Set("PJSIP/501-0000002b", "DIALSTATUS=") in new stack
    -- Executing [s@macro-dial:33] GosubIf("PJSIP/501-0000002b", "0?,1()") in new stack
    -- Executing [s@macro-dial:34] NoOp("PJSIP/501-0000002b", "Returning since nobody answered") in new stack
    -- Executing [s@macro-dial:35] Return("PJSIP/501-0000002b", "") in new stack
    -- Executing [300@from-internal:10] Hangup("PJSIP/501-0000002b", "") in new stack
  == Spawn extension (from-internal, 300, 10) exited non-zero on 'PJSIP/501-0000002b'
    -- Executing [h@from-internal:1] Gosub("PJSIP/501-0000002b", "macro-hangupcall,s,1") in new stack
    -- Executing [s@macro-hangupcall:1] Set("PJSIP/501-0000002b", "__MCVMSTATUS=") in new stack
    -- Executing [s@macro-hangupcall:2] Gosub("PJSIP/501-0000002b", "app-missedcall-hangup,s,1()") in new stack
    -- Executing [s@app-missedcall-hangup:1] NoOp("PJSIP/501-0000002b", "Dialed: s") in new stack
    -- Executing [s@app-missedcall-hangup:2] NoOp("PJSIP/501-0000002b", "Caller: 501") in new stack
    -- Executing [s@app-missedcall-hangup:3] GotoIf("PJSIP/501-0000002b", "0?exit") in new stack
    -- Executing [s@app-missedcall-hangup:4] Set("PJSIP/501-0000002b", "EXTENNUM=s") in new stack
    -- Executing [s@app-missedcall-hangup:5] Set("PJSIP/501-0000002b", "FEXTENNUM=s") in new stack
    -- Executing [s@app-missedcall-hangup:6] GotoIf("PJSIP/501-0000002b", "0?exit") in new stack
    -- Executing [s@app-missedcall-hangup:7] AGI("PJSIP/501-0000002b", "agi://127.0.0.1/missedcallnotify.php,s,,s,0,,PJSIP/501-0000002b,,,,") in new stack
    -- <PJSIP/501-0000002b>AGI Script agi://127.0.0.1/missedcallnotify.php completed, returning 0
    -- Executing [s@app-missedcall-hangup:8] Return("PJSIP/501-0000002b", "") in new stack
    -- Executing [s@macro-hangupcall:3] UserEvent("PJSIP/501-0000002b", "MES,RTPAUDIOQOSMESBRIDGED:,RTPAUDIOQOSMES:") in new stack
    -- Executing [s@macro-hangupcall:4] GotoIf("PJSIP/501-0000002b", "1?theend") in new stack
    -- Goto (macro-hangupcall,s,6)
    -- Executing [s@macro-hangupcall:6] ExecIf("PJSIP/501-0000002b", "0?Set(CDR(recordingfile)=)") in new stack
    -- Executing [s@macro-hangupcall:7] Hangup("PJSIP/501-0000002b", "") in new stack
  == Spawn extension (macro-hangupcall, s, 7) exited non-zero on 'PJSIP/501-0000002b'


ChatGPT Plus
Gracias por compartir los logs detallados. Este registro confirma que Asterisk efectivamente construye el dial string para llamar a la secretaria, pero nunca llega a ejecutar el Dial(). Vamos directo al an√°lisis.

‚úÖ Lo que s√≠ est√° bien
De los logs:

perl
Copiar
Editar
agi://127.0.0.1/dialparties.agi: Ended up with real PJSIP Dial string PJSIP/301/sip:301@10.1.2.168:63086;ob
...
-- Executing [s@macro-dial:15] Set("...", "ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr") in new stack
‚úÖ El dial string ds fue correctamente creado.

‚úÖ El sistema reconoci√≥ al interno 301, est√° disponible y no est√° en DND.

‚úÖ Se cre√≥ el contexto ds, el canal SIP est√° correcto.

‚ùå Lo que no sucede
Lo que falta completamente en los logs es esta l√≠nea t√≠pica:

scss
Copiar
Editar
-- Executing [s@macro-dial:36] Dial(${ds},20,HhTtr)
Y eso significa que el Dial() nunca se ejecut√≥, aunque ds est√© correctamente armado.

üîç ¬øPor qu√© no se ejecuta el Dial()?
Porque m√°s abajo en el log, Asterisk entra en:

typescript
Copiar
Editar
-- Executing [s@macro-dial:30] ExecIf("...", "0?Set(ds=...)") in new stack
-- Executing [s@macro-dial:31] Gosub("...", "dial-with-exten,,1()") in new stack
-- Executing [s@dial-with-exten:1] Return("...", "") in new stack
-- Executing [s@macro-dial:32] Set("...", "DIALSTATUS=") in new stack
-- Executing [s@macro-dial:34] NoOp("...", "Returning since nobody answered")
-- Executing [s@macro-dial:35] Return("...", "") in new stack
üí• Este flujo indica que:

Asterisk crey√≥ que no hab√≠a internos para llamar, o ringall estaba vac√≠o.

No entr√≥ al paso donde efectivamente se marca (Dial(${ds})).

Esto puede pasar si ringall (la variable que se llena con los internos a marcar) se queda vac√≠a.

‚úÖ Soluci√≥n: Forzar ring group interno (aunque sea uno solo)
FreePBX espera que los destinos de macro-dial est√©n como si fueran una lista tipo ring group. En tu caso, al llamar con 301, si no lo pas√°s correctamente o falta alg√∫n dato en la base de datos interna, puede que ringall quede vac√≠o.

üîß Recomendado:
Us√° 301- en vez de 301 como tercer argumento:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301-))
El guion (-) le indica a dialparties.agi que es parte de un ring group.

Esto rellena correctamente la variable ringall.

üîÅ Alternativa avanzada: invocar dialparties.agi manualmente
Si quer√©s reemplazar por completo macro-dial, podr√≠as directamente construir tu l√≥gica de llamada a la secretaria sin usar ese macro (opcional).

‚úÖ Resumen de pasos sugeridos
Cambi√° la l√≠nea actual:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301))
por:

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301-))
(Opcional) Agreg√° un NoOp para verificar si ds se llena:

asterisk
Copiar
Editar
exten => 300,n,NoOp(ds=${ds})
Verific√° en los nuevos logs que aparezca algo como:

scss
Copiar
Editar
-- Executing [s@macro-dial:36] Dial(PJSIP/301/sip:301@...,20,HhTtr)
¬øQuer√©s que te arme una versi√≥n de este m√≥dulo con bypass de macro-dial (es decir, con un Dial() directo)? Es √∫til si no quer√©s depender del flujo interno de FreePBX.








T√∫ dijiste:
-- Executing [300@from-internal:6] NoOp("PJSIP/501-0000002c", "Bosssecretary: Executing module") in new stack
    -- Executing [300@from-internal:7] Set("PJSIP/501-0000002c", "PJSIP_HEADER(add,Alert-Info)=<http://nohost>;info=alert-group;x-line-id=0") in new stack
    -- Executing [300@from-internal:8] NoOp("PJSIP/501-0000002c", "RINGTIMER=, DIAL_OPTIONS=HhTtr") in new stack
    -- Executing [300@from-internal:9] Gosub("PJSIP/501-0000002c", "macro-dial,s,1(20,HhTtr,301-)") in new stack
    -- Executing [s@macro-dial:1] NoOp("PJSIP/501-0000002c", "Blind Transfer: , Attended Transfer: , User: 501, Alert Info: ") in new stack
    -- Executing [s@macro-dial:2] Set("PJSIP/501-0000002c", "__CRM_SOURCE=501") in new stack
    -- Executing [s@macro-dial:3] ExecIf("PJSIP/501-0000002c", "1?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:4] ExecIf("PJSIP/501-0000002c", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:5] ExecIf("PJSIP/501-0000002c", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:6] ExecIf("PJSIP/501-0000002c", "0?Set(CHANNEL(musicclass)=)") in new stack
    -- Executing [s@macro-dial:7] AGI("PJSIP/501-0000002c", "agi://127.0.0.1/dialparties.agi") in new stack
 agi://127.0.0.1/dialparties.agi: Starting New Dialparties.agi
 agi://127.0.0.1/dialparties.agi: Caller ID name is '501' number is '501'
 agi://127.0.0.1/dialparties.agi: CW Ignore is:
 agi://127.0.0.1/dialparties.agi: CF Ignore is:
 agi://127.0.0.1/dialparties.agi: CW IN_USE/BUSY is: 1
 agi://127.0.0.1/dialparties.agi: Ringgroup confirm is  :
        > agi://127.0.0.1/dialparties.agi: USE_CONFIRMATION:  'FALSE'
        > agi://127.0.0.1/dialparties.agi: RINGGROUP_INDEX:   ''
 agi://127.0.0.1/dialparties.agi: Methodology of ring is  'none'
    -- agi://127.0.0.1/dialparties.agi: Added extension 301 to extension map
    -- agi://127.0.0.1/dialparties.agi: Added extension  to extension map
    -- agi://127.0.0.1/dialparties.agi: Extension 301 cf is disabled
    -- agi://127.0.0.1/dialparties.agi: Extension  cf is disabled
    -- agi://127.0.0.1/dialparties.agi: Extension 301 do not disturb is disabled
    -- agi://127.0.0.1/dialparties.agi: Extension  do not disturb is disabled
       > agi://127.0.0.1/dialparties.agi: extnum 301 has:  cw: 1; hascfb: 0 [] hascfu: 0 []
 agi://127.0.0.1/dialparties.agi: EXTENSION_STATE: 0 (NOT_INUSE)
  == agi://127.0.0.1/dialparties.agi: Discovered PJSIP Endpoint PJSIP/301
    -- agi://127.0.0.1/dialparties.agi: Ended up with real PJSIP Dial string PJSIP/301/sip:301@10.1.2.168:63086;ob
    -- agi://127.0.0.1/dialparties.agi: dbset CALLTRACE/301 to 501
       > agi://127.0.0.1/dialparties.agi: extnum  has:  cw: 0; hascfb: 0 [] hascfu: 0 []
[2025-07-11 12:33:47] WARNING[13250][C-0000001e]: func_extstate.c:117 extstate_read: EXTENSION_STATE requires an extension
 agi://127.0.0.1/dialparties.agi: EXTENSION_STATE: 4 ()
 agi://127.0.0.1/dialparties.agi: Extension  has ExtensionState: 4
    -- agi://127.0.0.1/dialparties.agi: Checking CW and CFB status for extension
 agi://127.0.0.1/dialparties.agi: Extension  is not available to be called
    -- agi://127.0.0.1/dialparties.agi: Filtered ARG3: 301
 agi://127.0.0.1/dialparties.agi: RVOL_MODE ''
 agi://127.0.0.1/dialparties.agi: RVOL is:
 agi://127.0.0.1/dialparties.agi: RVOLPARENT is:
    -- <PJSIP/501-0000002c>AGI Script agi://127.0.0.1/dialparties.agi completed, returning 0
    -- Executing [s@macro-dial:8] GotoIf("PJSIP/501-0000002c", "1?normdial") in new stack
    -- Goto (macro-dial,s,11)
    -- Executing [s@macro-dial:11] NoOp("PJSIP/501-0000002c", "Returned from dialparties with groups to dial") in new stack
    -- Executing [s@macro-dial:12] NoOp("PJSIP/501-0000002c", "ringall array  ") in new stack
    -- Executing [s@macro-dial:13] NoOp("PJSIP/501-0000002c", "ds= PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr ") in new stack
    -- Executing [s@macro-dial:14] NoOp("PJSIP/501-0000002c", "dsextra= ") in new stack
    -- Executing [s@macro-dial:15] Set("PJSIP/501-0000002c", "ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr") in new stack
    -- Executing [s@macro-dial:16] NoOp("PJSIP/501-0000002c", "ds= PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr") in new stack
    -- Executing [s@macro-dial:17] Set("PJSIP/501-0000002c", "__FMGL_DIAL=") in new stack
    -- Executing [s@macro-dial:18] Set("PJSIP/501-0000002c", "LOOPCNT=1") in new stack
    -- Executing [s@macro-dial:19] Set("PJSIP/501-0000002c", "ITER=1") in new stack
    -- Executing [s@macro-dial:20] Set("PJSIP/501-0000002c", "__EXTTOCALL=301") in new stack
    -- Executing [s@macro-dial:21] Set("PJSIP/501-0000002c", "__MCEXTTOCALL=301") in new stack
    -- Executing [s@macro-dial:22] NoOp("PJSIP/501-0000002c", "Working with 301") in new stack
    -- Executing [s@macro-dial:23] ExecIf("PJSIP/501-0000002c", "0?Set(HASH(__SIPHEADERS,Alert-Info)=Normal;volume=)") in new stack
    -- Executing [s@macro-dial:24] ExecIf("PJSIP/501-0000002c", "0?Set(HASH(__SIPHEADERS,Alert-Info)=Normal;volume=)") in new stack
    -- Executing [s@macro-dial:25] Set("PJSIP/501-0000002c", "ITER=2") in new stack
    -- Executing [s@macro-dial:26] GotoIf("PJSIP/501-0000002c", "0?ndloopbegin") in new stack
    -- Executing [s@macro-dial:27] Gosub("PJSIP/501-0000002c", "macro-dial-ringall-predial-hook,s,1()") in new stack
    -- Executing [s@macro-dial-ringall-predial-hook:1] Return("PJSIP/501-0000002c", "") in new stack
    -- Executing [s@macro-dial:28] ExecIf("PJSIP/501-0000002c", "0?Set(CWRING=r(callwaiting)):Set(CWRING=)") in new stack
    -- Executing [s@macro-dial:29] ExecIf("PJSIP/501-0000002c", "0?Set(RGFMDIAL=301):Set(RGFMDIAL=)") in new stack
    -- Executing [s@macro-dial:30] ExecIf("PJSIP/501-0000002c", "0?Set(ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtrg)") in new stack
    -- Executing [s@macro-dial:31] Gosub("PJSIP/501-0000002c", "dial-with-exten,,1()") in new stack
    -- Executing [s@dial-with-exten:1] Return("PJSIP/501-0000002c", "") in new stack
    -- Executing [s@macro-dial:32] Set("PJSIP/501-0000002c", "DIALSTATUS=") in new stack
    -- Executing [s@macro-dial:33] GosubIf("PJSIP/501-0000002c", "0?,1()") in new stack
    -- Executing [s@macro-dial:34] NoOp("PJSIP/501-0000002c", "Returning since nobody answered") in new stack
    -- Executing [s@macro-dial:35] Return("PJSIP/501-0000002c", "") in new stack
    -- Executing [300@from-internal:10] NoOp("PJSIP/501-0000002c", "ds=PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr") in new stack
    -- Executing [300@from-internal:11] Hangup("PJSIP/501-0000002c", "") in new stack
  == Spawn extension (from-internal, 300, 11) exited non-zero on 'PJSIP/501-0000002c'
    -- Executing [h@from-internal:1] Gosub("PJSIP/501-0000002c", "macro-hangupcall,s,1") in new stack
    -- Executing [s@macro-hangupcall:1] Set("PJSIP/501-0000002c", "__MCVMSTATUS=") in new stack
    -- Executing [s@macro-hangupcall:2] Gosub("PJSIP/501-0000002c", "app-missedcall-hangup,s,1()") in new stack
    -- Executing [s@app-missedcall-hangup:1] NoOp("PJSIP/501-0000002c", "Dialed: s") in new stack
    -- Executing [s@app-missedcall-hangup:2] NoOp("PJSIP/501-0000002c", "Caller: 501") in new stack
    -- Executing [s@app-missedcall-hangup:3] GotoIf("PJSIP/501-0000002c", "0?exit") in new stack
    -- Executing [s@app-missedcall-hangup:4] Set("PJSIP/501-0000002c", "EXTENNUM=s") in new stack
    -- Executing [s@app-missedcall-hangup:5] Set("PJSIP/501-0000002c", "FEXTENNUM=s") in new stack
    -- Executing [s@app-missedcall-hangup:6] GotoIf("PJSIP/501-0000002c", "0?exit") in new stack
    -- Executing [s@app-missedcall-hangup:7] AGI("PJSIP/501-0000002c", "agi://127.0.0.1/missedcallnotify.php,s,,s,0,,PJSIP/501-0000002c,,,,") in new stack
    -- <PJSIP/501-0000002c>AGI Script agi://127.0.0.1/missedcallnotify.php completed, returning 0
    -- Executing [s@app-missedcall-hangup:8] Return("PJSIP/501-0000002c", "") in new stack
    -- Executing [s@macro-hangupcall:3] UserEvent("PJSIP/501-0000002c", "MES,RTPAUDIOQOSMESBRIDGED:,RTPAUDIOQOSMES:") in new stack
    -- Executing [s@macro-hangupcall:4] GotoIf("PJSIP/501-0000002c", "1?theend") in new stack
    -- Goto (macro-hangupcall,s,6)
    -- Executing [s@macro-hangupcall:6] ExecIf("PJSIP/501-0000002c", "0?Set(CDR(recordingfile)=)") in new stack
    -- Executing [s@macro-hangupcall:7] Hangup("PJSIP/501-0000002c", "") in new stack


ChatGPT Plus
Gracias por compartir el nuevo log. Ahora el problema est√° perfectamente claro.

‚ö†Ô∏è PROBLEMA ACTUAL:
El log dice:

typescript
Copiar
Editar
-- Executing [s@macro-dial:32] Set("PJSIP/501-0000002c", "DIALSTATUS=") in new stack
-- Executing [s@macro-dial:34] NoOp("PJSIP/501-0000002c", "Returning since nobody answered")
Nunca llama.
Aunque el dial string ds est√° bien armado:

ini
Copiar
Editar
ds= PJSIP/301/sip:301@10.1.2.168:63086;ob,20,HhTtr
Pero NO HACE EL DIAL().

üß† ¬øPor qu√© no llama aunque ds est√° bien?
Porque FreePBX depende de que ringall (lista de internos a marcar) contenga al menos un interno v√°lido, y dialparties.agi est√° recibiendo un destino vac√≠o adicional.

Fijate en este fragmento:

pgsql
Copiar
Editar
agi://127.0.0.1/dialparties.agi: Added extension 301 to extension map
agi://127.0.0.1/dialparties.agi: Added extension  to extension map
Ese segundo "extension " (vac√≠o) es el problema.

Y m√°s abajo:

pgsql
Copiar
Editar
agi://127.0.0.1/dialparties.agi: Extension  is not available to be called
üí• Esa entrada vac√≠a hace que ringall quede inconsistente.

‚úÖ SOLUCI√ìN
No uses "301-", us√° directamente "301".

La causa del error es ese guion final, que al parecer FreePBX lo interpreta como "lista terminada en coma", y le suma un destino vac√≠o.

Entonces:
ANTES (incorrecto):

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301-))
DESPU√âS (correcto):

asterisk
Copiar
Editar
exten => 300,n,Gosub(macro-dial,s,1(20,HhTtr,301))
Aunque antes parec√≠a que no entraba al Dial() con "301", el problema estaba probablemente en el flujo posterior (quiz√°s lo hab√≠as corregido parcialmente o la secretaria no estaba disponible en ese momento). Ahora, como 301 responde bien, esto funcionar√°.

üß™ ¬øQuer√©s forzar a que s√≠ o s√≠ marque?
Si quer√©s asegurarte sin depender de macro-dial, pod√©s hacer este reemplazo directo:

asterisk
Copiar
Editar
exten => 300,n,Dial(PJSIP/301,20,HhTtr)
Pero ya que est√°s trabajando dentro del m√≥dulo BossSecretary, es mejor mantener compatibilidad con FreePBX y macro-dial, siempre que funcione.

¬øQuer√©s que al no contestar la 301 se derive a otra extensi√≥n o correo de voz? Tambi√©n se puede agregar eso despu√©s del macro-dial.








T√∫ dijiste:
en el codigo del modulo, como cambio $ext->add($ctx_bsc, $extension, '', new ext_sipaddheader("Alert-Info", "<http://nohost>\;info=alert-group\;x-line-id=0")); para que use pjsip?


ChatGPT Plus
En FreePBX, si quer√©s que tu m√≥dulo agregue un header personalizado para llamadas con PJSIP, NO deb√©s usar ext_sipaddheader, porque eso es para canales SIP (chan_sip), que est√°n obsoletos.

‚úÖ En su lugar, us√°:
php
Copiar
Editar
new ext_set("PJSIP_HEADER(add,Alert-Info)", "<http://nohost>;info=alert-group;x-line-id=0")
üîÅ Entonces, reemplaz√°:
php
Copiar
Editar
$ext->add($ctx_bsc, $extension, '', new ext_sipaddheader("Alert-Info", "<http://nohost>\;info=alert-group\;x-line-id=0"));
Por esto:

php
Copiar
Editar
$ext->add($ctx_bsc, $extension, '', new ext_set("PJSIP_HEADER(add,Alert-Info)", "<http://nohost>;info=alert-group;x-line-id=0"));
üìå Aclaraci√≥n sobre los ;
En el ext_sipaddheader() usabas \; para escapar porque se trataba de un string SIP literal.

En ext_set("PJSIP_HEADER(...)"), NO es necesario escaparlos, porque es un comando Asterisk Set() que interpreta correctamente los ;.

¬øQuer√©s que te muestre c√≥mo quedar√≠a el bloque completo de c√≥digo del m√≥dulo con eso aplicado correctamente?








T√∫ dijiste:
tengo 2 centrales, una con los numeros 300 (jefe), 301 (secretaria) y otra con el numero 1851. Cuando llamo al 301 lo hace sin problema (pongo un prefijo #44 para llamar a la primera central), pero cuando llamo al 300 da ocupado y no parece ejecutarse el modulo


ChatGPT Plus
Gracias por el contexto. El hecho de que llamar al 301 (secretaria) desde la otra central funcione usando #44, pero que al 300 (jefe) te d√© ocupado y no dispare el m√≥dulo BossSecretary, sugiere que:

üîç El problema est√° en c√≥mo llega la llamada al 300 desde la otra central:
Tu m√≥dulo probablemente est√° colgado del contexto from-internal, que es el usado cuando disc√°s localmente, pero las llamadas entre centrales suelen entrar por otro contexto, como from-trunk, from-pstn, from-sip-external, o algo personalizado.

‚úÖ Soluciones
‚úÖ 1. Verific√° el contexto de entrada
Hac√© una llamada desde la central remota al 300, y en la consola de Asterisk pon√©:

bash
Copiar
Editar
core set verbose 10
core set debug 10
y observ√° algo como esto:

text
Copiar
Editar
-- Executing [300@from-trunk:1] ...
Lo importante es la parte 300@from-XXXX, porque eso indica el contexto desde donde se ejecuta.

‚úÖ 2. Asegurate de colgar el m√≥dulo en todos los contextos relevantes
Si tu m√≥dulo solo se engancha en from-internal, agreg√° esta l√≠nea tambi√©n para from-trunk o el que corresponda:

php
Copiar
Editar
$ext->add('from-trunk', '300', 1, new ext_goto('from-internal', '300', '1'));
O directamente inclu√≠ tu contexto personalizado en from-trunk:

ini
Copiar
Editar
[from-trunk]
include => bosssecretary
‚úÖ 3. Verific√° que el n√∫mero est√© bien mapeado
Tambi√©n puede que est√© cayendo directamente en el ext-local, ignorando tu l√≥gica. Si us√°s rutas entrantes con coincidencia de DID, asegurate de que la llamada al 300 realmente pase por donde est√° colgado tu c√≥digo.

‚úÖ 4. Cheque√° qu√© dice la consola cuando disc√°s al 300
Busc√° algo como:

text
Copiar
Editar
-- Executing [300@from-internal:6] NoOp("... Bosssecretary: Executing module") ...
Si eso no aparece, el m√≥dulo no se est√° ejecutando. Necesit√°s modificar el dialplan de entrada para que pase por tu contexto.

‚úÖ 5. ¬øTen√©s Time Conditions u otro override?
Si hay una Time Condition o IVR que est√° interceptando llamadas al 300, puede que est√© dirigiendo la llamada directo al destino sin pasar por tu c√≥digo.

¬øQu√© pod√©s hacer ahora?
Llam√° desde la central remota al 300.

Observ√° en consola Asterisk qu√© contexto est√° usando (300@???).

Mostrame esa l√≠nea y te digo exactamente c√≥mo enganchar tu m√≥dulo ah√≠.

¬øTe gustar√≠a que prepare un extensions_custom.conf con una l√≥gica para derivar correctamente a bosssecretary desde cualquier entrada a 300?








T√∫ dijiste:
el contexto es from-pstn


ChatGPT Plus
Perfecto, gracias. Entonces tu m√≥dulo est√° colgado en from-internal, pero cuando llam√°s desde la otra central, la llamada entra por from-pstn, por lo tanto el m√≥dulo bosssecretary nunca se ejecuta.

‚úÖ Soluci√≥n
Ten√©s dos formas de redirigir el tr√°fico entrante hacia donde s√≠ se ejecuta el m√≥dulo:

üîÅ Opci√≥n 1: Redirigir el from-pstn al from-internal
En tu extensions_custom.conf, agreg√° esto:

ini
Copiar
Editar
[from-pstn]
exten => 300,1,Goto(from-internal,300,1)
Esto hace que cualquier llamada al 300 que entre por from-pstn salte directamente a from-internal,300,1, donde est√° tu l√≥gica de BossSecretary.

Ventaja: No duplic√°s l√≥gica.
Desventaja: Si en alg√∫n momento quer√©s un comportamiento distinto para llamadas externas, no pod√©s.

üß± Opci√≥n 2: Inyectar la l√≥gica directamente en from-pstn
Si quer√©s que el m√≥dulo se ejecute incluso sin pasar por from-internal, pod√©s incluir tu contexto ah√≠ tambi√©n:

ini
Copiar
Editar
[from-pstn]
include => bosssecretary
Y asegurate de que en tu m√≥dulo tengas algo como:

php
Copiar
Editar
$ext->add('bosssecretary', '300', 1, new ext_noop('Bosssecretary: Executing module'));
// ... l√≥gica del m√≥dulo ...
üìå Recomendaci√≥n
La opci√≥n 1 (Goto a from-internal) es m√°s clara y no requiere replicar l√≥gica. Es lo que m√°s se usa en producci√≥n, por ejemplo:

ini
Copiar
Editar
[from-pstn]
exten => 300,1,NoOp(Call from remote PBX)
 same => n,Goto(from-internal,300,1)
üìû ¬øQuer√©s que tambi√©n funcione con 301?
Si alg√∫n d√≠a quer√©s que 301 (la secretaria) tambi√©n tenga l√≥gica similar desde otras centrales, hac√© lo mismo:

ini
Copiar
Editar
exten => 301,1,Goto(from-internal,301,1)
¬øQuer√©s que revise tu install.php para que autom√°ticamente cree esta redirecci√≥n si el m√≥dulo lo instala?








T√∫ dijiste:
si, que deberia pasarte?


ChatGPT Plus
Genial. Para ayudarte a que el install.php de tu m√≥dulo bosssecretary:

inserte la redirecci√≥n de from-pstn ‚Üí from-internal,

y lo haga de forma segura sin romper la l√≥gica de otras extensiones,

necesito que me pases tu archivo install.php completo, o al menos la parte donde agreg√°s las extensiones o modific√°s el dialplan. Busco algo como esto:

php
Copiar
Editar
$ext = $GLOBALS['ext']; // o similar
$ctx_bsc = 'bosssecretary';
// luego llamadas a $ext->add(...)
Si quer√©s adelantarlo, pod√©s buscarme:
¬øD√≥nde defin√≠s los contextos? ($ctx_bsc = ...)

¬øD√≥nde hac√©s el add al $ext?

¬øD√≥nde est√° el featurecode si lo us√°s?

Mientras tanto, te dejo el fragmento base que podr√≠amos usar:
php
Copiar
Editar
// Redirige llamadas de 'from-pstn' al 300 hacia 'from-internal'
$ext->add('from-pstn', '300', 1, new ext_goto('from-internal,300,1'));
Esto lo pod√©s agregar al final del install() o do_install().

Con el archivo completo, puedo integrarlo correctamente, evitar duplicaciones, y asegurarme de que no se pise si el usuario lo reinstala. ¬øQuer√©s subirlo o pegarlo ac√°?








T√∫ dijiste:
install.php:

<?php


$fcc = new featurecode('bosssecretary', 'bsc_toggle');
$fcc->setDescription('Bosssecretary Toggle');
$fcc->setDefault('*152');
$fcc->update();
unset($fcc);

$fcc = new featurecode('bosssecretary', 'bsc_on');
$fcc->setDescription('Bosssecretary On');
$fcc->setDefault('*153');
$fcc->update();
unset($fcc);


$fcc = new featurecode('bosssecretary', 'bsc_off');
$fcc->setDescription('Bosssecretary Off');
$fcc->setDefault('*154');
$fcc->update();
unset($fcc);



$sql = " DROP TABLE IF EXISTS  bosssecretary_config";
$check = $db->query($sql);
if(DB::IsError($check)) {
	die_freepbx("Can not drop bosssecretary_config table");
}

 


$sql = "
CREATE TABLE IF NOT EXISTS bosssecretary_chief (
  id_group int(10) unsigned NOT NULL,
  chief_extension varchar(20) NOT NULL,
  PRIMARY KEY (id_group,chief_extension)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
";
$check = $db->query($sql);
if(DB::IsError($check)) {
	die_freepbx("Can not create bosssecretary_chief table");
}

$sql = "
CREATE TABLE IF NOT EXISTS bosssecretary_boss (
  id_group int(10) unsigned NOT NULL,
  boss_extension varchar(20) NOT NULL,
  PRIMARY KEY (id_group,boss_extension)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
";
$check = $db->query($sql);
if(DB::IsError($check)) {
        die_freepbx("Can not create bosssecretary_boss table");
}



$sql = "
CREATE TABLE IF NOT EXISTS bosssecretary_group (
  id_group int(10) unsigned NOT NULL AUTO_INCREMENT,
  label varchar(20) NOT NULL,
  PRIMARY KEY (id_group)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
";
$check = $db->query($sql);
if(DB::IsError($check)) {
	die_freepbx("Can not create bosssecretary_group table");
}



$sql = "SHOW COLUMNS FROM bosssecretary_group";
$results = $db->getAll($sql);
if(DB::IsError($results)) {
	die_freepbx("Can not check bosssecretary_group table");
}

foreach ($results as $column)
{
    if (!isset($column["Field"])) {
        continue;
    }

    $fieldName = trim(strtolower($column["Field"]));

    if ($fieldName == "dring") {
        $sql = "ALTER TABLE bosssecretary_group DROP ".$column["Field"]." ";
        $check = $db->query($sql);
        if(DB::IsError($check)) {
            die_freepbx("Can not alter bosssecretary_group table");
        }
    }
    if ($fieldName == "ringtime") {
        $sql = "ALTER TABLE bosssecretary_group DROP ".$column["Field"]." ";
        $check = $db->query($sql);
        if(DB::IsError($check)) {
            die_freepbx("Can not alter bosssecretary_group table");
        }
    }
}

$sql = "ALTER TABLE bosssecretary_group MODIFY id_group INT(10) NOT NULL";
$results = $db->query($sql);
if(DB::IsError($results)) {
	die_freepbx("Can not modify bosssecretary_group.id_group column");
}

$sql = "
CREATE TABLE IF NOT EXISTS bosssecretary_secretary (
  id_group int(11) NOT NULL,
  secretary_extension varchar(20) NOT NULL,
  PRIMARY KEY (id_group,secretary_extension)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
";
$check = $db->query($sql);
if(DB::IsError($check)) {
	die_freepbx("Can not create bosssecretary_secretary table");
}


$sql = "
CREATE TABLE IF NOT EXISTS bosssecretary_group_numbers_free (
  group_number int(10) unsigned NOT NULL,
  PRIMARY KEY (group_number)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
";

$check = $db->query($sql);
if(DB::IsError($check)) {
	die_freepbx("Can not create bosssecretary_group_numbers_free");
}



?>


ChatGPT Plus
Gracias, Yoko. Tu archivo install.php actualmente crea los feature codes y las tablas necesarias, pero no modifica el dialplan Asterisk (o sea, no agrega ning√∫n contexto, ni dialplan din√°mico con $ext->add(...)).

‚úÖ ¬øQu√© queremos lograr?
Quer√©s que cuando una llamada externa entre por from-pstn y marque, por ejemplo, el 300, se dispare tu l√≥gica del m√≥dulo bosssecretary, que est√° normalmente en el contexto from-internal.

üîß Soluci√≥n
Agreg√° al final de tu install.php este bloque para redirigir las llamadas entrantes del 300 desde el contexto from-pstn hacia el contexto from-internal:

php
Copiar
Editar
$ext = $GLOBALS['ext']; // acceso al generador de dialplan de FreePBX
$ext->add('from-pstn', '300', '', new ext_goto('from-internal,300,1'));
üìå Esto hace que cuando alguien llame al 300 desde afuera (from-pstn), se redirija autom√°ticamente a from-internal,300,1, donde vos ten√©s la l√≥gica del m√≥dulo (como ext_sipaddheader, etc.).

üõ† Posible mejora adicional (opcional)
Si vas a tener varios jefes (ej: 300, 305, 310...), pod√©s hacer algo m√°s din√°mico, como usar una macro o custom context (bosssecretary-inbound) y ah√≠ hacer el enrutamiento. Pero para una soluci√≥n puntual, con 300 basta con lo de arriba.

üì¶ Resultado Final
Agreg√° esto al final del install.php:

php
Copiar
Editar
$ext = $GLOBALS['ext'];
$ext->add('from-pstn', '300', '', new ext_goto('from-internal,300,1'));
¬øQuer√©s que te ayude a extenderlo para m√∫ltiples internos tambi√©n (301, etc.)?








T√∫ dijiste:
quiero que funcione para jefes de distintos numeros


ChatGPT Plus
Perfecto. Entonces lo ideal es no hardcodear el n√∫mero 300, sino derivar cualquier n√∫mero que sea un jefe a tu contexto from-internal (donde ya ejecut√°s la l√≥gica del m√≥dulo bosssecretary).

‚úÖ ¬øC√≥mo hacerlo din√°mico?
Ya ten√©s una tabla bosssecretary_boss donde est√°n listadas las extensiones de los jefes (boss_extension). Vamos a usar esa tabla para generar una entrada en el contexto from-pstn para cada jefe registrado.

üîß Agreg√° esto al final de tu install.php:
php
Copiar
Editar
$ext = $GLOBALS['ext'];

// Buscar todas las extensiones de jefes
$sql = "SELECT boss_extension FROM bosssecretary_boss";
$results = $db->getAll($sql, DB_FETCHMODE_ASSOC);

if (DB::IsError($results)) {
    die_freepbx("Error al obtener las extensiones de jefes");
}

foreach ($results as $row) {
    $boss_ext = trim($row['boss_extension']);
    if ($boss_ext !== '') {
        $ext->add('from-pstn', $boss_ext, '', new ext_goto("from-internal,{$boss_ext},1"));
    }
}
üí° ¬øQu√© hace este c√≥digo?
Lee de la tabla bosssecretary_boss todos los internos marcados como jefes.

Por cada uno, crea una entrada en el contexto from-pstn para redirigir al contexto from-internal, donde ya est√° tu l√≥gica.

‚úÖ Requisitos
Para que esto funcione:

Los internos jefes (300, 305, etc.) deben estar correctamente cargados en bosssecretary_boss.

La llamada entrante debe ir al context=from-pstn (como est√°s haciendo ahora).

El dialplan de FreePBX debe regenerarse luego de instalar el m√≥dulo:

Ejecut√°:

bash
Copiar
Editar
fwconsole reload
¬øQuer√©s que tambi√©n funcione para llamadas entrantes que vengan con prefijos (como #44) o solo para las que terminan en un interno conocido?








T√∫ dijiste:
cuando hago fwconsole reload me tira:
In functions.inc.php line 73:

  Undefined array key "chiefs"


ChatGPT Plus
Ese error:

pgsql
Copiar
Editar
In functions.inc.php line 73:
  Undefined array key "chiefs"
indica que en tu archivo functions.inc.php est√°s intentando acceder al √≠ndice "chiefs" de un array que no lo tiene definido a√∫n.

üîç Diagn√≥stico
Es probable que est√©s haciendo algo como esto:

php
Copiar
Editar
$someArray['chiefs'][] = $value;
Pero nunca inicializaste $someArray['chiefs'] como un array antes. Entonces PHP lanza un error.

‚úÖ Soluci√≥n
Antes de usar ese √≠ndice, asegurate de inicializarlo. Por ejemplo:

php
Copiar
Editar
if (!isset($someArray['chiefs'])) {
    $someArray['chiefs'] = array();
}
$someArray['chiefs'][] = $value;
O de forma m√°s compacta en PHP moderno:

php
Copiar
Editar
$someArray['chiefs'][] = $value; // Error si 'chiefs' no existe

// Soluci√≥n:
$someArray['chiefs'] ??= [];
$someArray['chiefs'][] = $value;
üõ† ¬øQuer√©s que te revise el functions.inc.php?
Si me peg√°s las primeras ~100 l√≠neas del archivo functions.inc.php de tu m√≥dulo (o al menos el bloque que incluye la l√≠nea 73), te indico exactamente qu√© y c√≥mo corregirlo.








T√∫ dijiste:
primeras 100 lineas:
<?php


/********************************************************
*														*
* 					API FUNCTIONS						*
*														*
********************************************************/


define("BOSSSECRETARY_PARAM_PREFIX", "bsgroup-");
define("BOSSSECRETARY_LABEL_DEFAULT", "Group ");
define("BOSSSECRETARY_CONTEXT", "ext-bosssecretary");
define("BOSSSECRETARY_MACRO_LOCKED", "macro-bosssecretary-locked");
define("BOSSSECRETARY_MACRO_LOCKED_NAME", "bosssecretary-locked");
define("BOSSSECRETARY_TOGGLE", "app-bosssecretary-toggle");
define("BOSSSECRETARY_ON", "app-bosssecretary-on");
define("BOSSSECRETARY_OFF", "app-bosssecretary-off");
define("BOSSSECRETARY_HINTS", "app-bosssecretary-hints");


function bosssecretary_get_config($engine){
	global $db;
	global $ext;
	global $amp_conf;
	global $astman;

	switch($engine) {
		case "asterisk":




			$fcc_toggle = bosssecretary_get_fcc_toggle();
			$fcc_on  = bosssecretary_get_fcc_on();
			$fcc_off  = bosssecretary_get_fcc_off();
			$groups = bosssecretary_get_all_groups();

			$ctx_app_toggle =   BOSSSECRETARY_TOGGLE;
			$ctx_app_on     =   BOSSSECRETARY_ON;
			$ctx_app_off    =   BOSSSECRETARY_OFF;
			$ctx_app_hints	=	BOSSSECRETARY_HINTS;
			$ctx_bsc		=	BOSSSECRETARY_CONTEXT;

			$ext->addInclude('from-internal-additional', $ctx_bsc);
			$ext->addInclude($ctx_bsc, $ctx_app_toggle);
			$ext->addInclude($ctx_bsc, $ctx_app_on);
			$ext->addInclude($ctx_bsc, $ctx_app_off);
			$ext->addInclude($ctx_bsc, $ctx_app_hints);

			if (!empty($groups))
			{

				$astman->database_deltree("bosssecretary/group");
				$groups = bosssecretary_to_group($groups);



				foreach ($groups as $group)
				{
					$id_group = $group["id_group"];

					foreach ($group["bosses"] as $extension)
					{
						$astman->database_put("bosssecretary","group/$id_group/member/$extension", "boss");
						$astman->database_put("bosssecretary","group/member/$extension", $id_group);
					}
					foreach ($group["secretaries"] as $extension)
					{
						$astman->database_put("bosssecretary","group/$id_group/member/$extension", "secretary");
						$astman->database_put("bosssecretary","group/member/$extension", $id_group);
					}
					foreach ($group["chiefs"] as $extension)
					{
						$astman->database_put("bosssecretary","group/$id_group/member/$extension", "chief");
					}
				}
				// :::: BSC Off [app-bosssecretary-on] ::::

				$ext->add($ctx_app_on, $fcc_on, '', new ext_noop("Bosssecretary on starts..."));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_answer());
				$ext->add($ctx_app_on, $fcc_on, '', new ext_macro ('user-callerid'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_wait ('2'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_gotoif('${DB_EXISTS(bosssecretary/group/member/${AMPUSER})}','on','exit'));
				$ext->add($ctx_app_on, $fcc_on, 'on', new ext_setvar('GROUP','${DB(bosssecretary/group/member/${AMPUSER})}'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_dbdel('bosssecretary/group/${GROUP}/locked'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_setvar('STATE','NOT_INUSE'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_gosub('1','sstate',$ctx_app_on));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_playback('activated'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_hangup());
				$ext->add($ctx_app_on, $fcc_on, 'exit', new ext_noop('${AMPUSER} doesn\\\'t belongs bosssecretary group'));
				$ext->add($ctx_app_on, $fcc_on, '', new ext_hangup());
				$ext->add($ctx_app_on, 'sstate', '', new ext_setvar('DEVICE_STATE(Custom:BSC${GROUP})','${STATE}'));
				$ext->add($ctx_app_on, 'sstate', 'return', new ext_return());


				// :::: BSC Off [app-bosssecretary-off] ::::
				$ext->add($ctx_app_off, $fcc_off, '', new ext_noop("Bosssecretary off starts..."));
				$ext->add($ctx_app_off, $fcc_off, '', new ext_answer());
				$ext->add($ctx_app_off, $fcc_off, '', new ext_macro ('user-callerid'));


ChatGPT Plus
Gracias. El error Undefined array key "chiefs" en la l√≠nea 73 proviene de esta parte del c√≥digo:

php
Copiar
Editar
foreach ($group["chiefs"] as $extension)
Eso ocurre si el array $group no tiene definido el √≠ndice "chiefs" en alguna de sus iteraciones.

‚úÖ Soluci√≥n
Antes de hacer foreach ($group["chiefs"] as $extension), asegurate de que la clave "chiefs" exista y sea un array. Pod√©s cambiar este bloque as√≠:

php
Copiar
Editar
if (isset($group["chiefs"]) && is_array($group["chiefs"])) {
	foreach ($group["chiefs"] as $extension) {
		$astman->database_put("bosssecretary", "group/$id_group/member/$extension", "chief");
	}
}
De esta forma evit√°s que el c√≥digo falle si alguna fila de la tabla bosssecretary_group no tiene asociados "chiefs".

üìå Recomendaci√≥n adicional
Revis√° la funci√≥n bosssecretary_to_group($groups) (que transforma los datos de la DB en estructuras como ["bosses" => [], "secretaries" => [], "chiefs" => []]) para asegurarte de que siempre devuelva todos los √≠ndices, aunque est√©n vac√≠os.

Ejemplo dentro de bosssecretary_to_group:

php
Copiar
Editar
$group["bosses"] = $group["bosses"] ?? [];
$group["secretaries"] = $group["secretaries"] ?? [];
$group["chiefs"] = $group["chiefs"] ?? [];
¬øQuer√©s que revise tambi√©n esa funci√≥n (bosssecretary_to_group) si me la pas√°s? Ah√≠ podr√≠amos asegurar de ra√≠z que nunca falte "chiefs".








T√∫ dijiste:
function bosssecretary_to_group($groups)
{
	$newGroup = array();
	foreach ($groups as $group)
	{
		if (!isset($newGroup[$group["id_group"]]))
		{
			$newGroup[$group["id_group"]] =  $group;
			$newGroup[$group["id_group"]]["bosses"] = array();
			// isset is so much faster than in_array ;)
			$newGroup[$group["id_group"]]["bosses"][$group["boss_extension"]] = $group["boss_extension"];

			$newGroup[$group["id_group"]]["secretaries"] = array();
			// isset is so much faster than in_array ;)
			$newGroup[$group["id_group"]]["secretaries"][$group["secretary_extension"]] = $group["secretary_extension"];

			if (isset($group["chief_extension"]))
			{
				$newGroup[$group["id_group"]]["chiefs"] = array();
				$newGroup[$group["id_group"]]["chiefs"][$group["chief_extension"]] = $group["chief_extension"];
			}
		}
		else
		{
			// isset is so much faster than in_array ;)
			if (!isset($newGroup[$group["id_group"]]["bosses"][$group["boss_extension"]]))
			{
				$newGroup[$group["id_group"]]["bosses"][$group["boss_extension"]] = $group["boss_extension"];
			}
			// isset is so much faster than in_array ;)
			if (!isset($newGroup[$group["id_group"]]["secretaries"][$group["secretary_extension"]]))
			{
				$newGroup[$group["id_group"]]["secretaries"][$group["secretary_extension"]] = $group["secretary_extension"];
			}
			if (!isset($newGroup[$group["id_group"]]["chiefs"][$group["chief_extension"]]))
			{
				$newGroup[$group["id_group"]]["chiefs"][$group["chief_extension"]] = $group["chief_extension"];
			}
		}
	}
	return $newGroup;
}


ChatGPT Plus
Perfecto. Gracias por compartir la funci√≥n bosssecretary_to_group.

El problema est√° claro: si un registro no tiene "chief_extension" definido, nunca se crea la clave "chiefs" en el array del grupo. Eso hace que luego, al iterar con $group["chiefs"], explote con Undefined array key.

‚úÖ Soluci√≥n recomendada
Forz√° que el √≠ndice "chiefs" exista, aunque sea un array vac√≠o.

Pod√©s hacer la funci√≥n m√°s robusta as√≠:

php
Copiar
Editar
function bosssecretary_to_group($groups)
{
	$newGroup = array();

	foreach ($groups as $group)
	{
		$id = $group["id_group"];

		if (!isset($newGroup[$id]))
		{
			$newGroup[$id] = $group;
			$newGroup[$id]["bosses"] = array();
			$newGroup[$id]["secretaries"] = array();
			$newGroup[$id]["chiefs"] = array(); // <-- Agreg√° esto siempre

			if (!empty($group["boss_extension"])) {
				$newGroup[$id]["bosses"][$group["boss_extension"]] = $group["boss_extension"];
			}
			if (!empty($group["secretary_extension"])) {
				$newGroup[$id]["secretaries"][$group["secretary_extension"]] = $group["secretary_extension"];
			}
			if (!empty($group["chief_extension"])) {
				$newGroup[$id]["chiefs"][$group["chief_extension"]] = $group["chief_extension"];
			}
		}
		else
		{
			if (!empty($group["boss_extension"]) && !isset($newGroup[$id]["bosses"][$group["boss_extension"]])) {
				$newGroup[$id]["bosses"][$group["boss_extension"]] = $group["boss_extension"];
			}
			if (!empty($group["secretary_extension"]) && !isset($newGroup[$id]["secretaries"][$group["secretary_extension"]])) {
				$newGroup[$id]["secretaries"][$group["secretary_extension"]] = $group["secretary_extension"];
			}
			if (!empty($group["chief_extension"]) && !isset($newGroup[$id]["chiefs"][$group["chief_extension"]])) {
				$newGroup[$id]["chiefs"][$group["chief_extension"]] = $group["chief_extension"];
			}
		}
	}

	return $newGroup;
}
‚úÖ Resultado
Con este cambio, ahora $group["chiefs"] siempre existe como array, y se evitar√° el error al hacer el foreach.

¬øQuer√©s que te ayude a revisar tambi√©n c√≥mo est√°n formadas las consultas SQL previas o la forma en que se construye $groups desde la base?








T√∫ dijiste:
no funciono lo de cambiar el install.php


ChatGPT Plus
Gracias por aclararlo. El error Undefined array key "chiefs" no depende del install.php, sino de c√≥mo se arma el array $groups que llega a la funci√≥n bosssecretary_to_group(...). Por eso el cambio debe hacerse directamente en esa funci√≥n, no en el install.php.

Revisemos paso a paso lo necesario:

‚úÖ 1. Tu error original:
php
Copiar
Editar
Undefined array key "chiefs"
Esto ocurre cuando se accede a:

php
Copiar
Editar
foreach ($group["chiefs"] as $extension) {
y el √≠ndice "chiefs" no fue definido.

‚úÖ 2. **El lugar donde se debe







T√∫ dijiste:
no funciono lo de cambiar el install.pho para cambiar el contexto de la llamada, o sea cuando cambie el extensions_custom funcion√≥ pero yo quiero que lo haga siempre y no te ner que hardcodearlo


ChatGPT Plus
Perfecto, gracias por la aclaraci√≥n. Lo que quer√©s es modificar el contexto de las extensiones (por ejemplo del jefe) para que apunten autom√°ticamente a tu m√≥dulo (ext-bosssecretary, por ejemplo), sin tener que editar a mano extensions_custom.conf o el plan de marcado manualmente. Te explico c√≥mo lograr eso correctamente.

üéØ Objetivo:
Modificar el contexto de la extensi√≥n (300, jefe) desde tu m√≥dulo de forma din√°mica para que vaya a tu l√≥gica (ext-bosssecretary), sin tener que tocar extensions_custom.conf a mano.

‚úÖ Soluci√≥n: Agreg√° una entrada en el contexto ext-local-custom
FreePBX no recomienda editar from-internal, pero s√≠ te permite usar ext-local-custom, que se incluye autom√°ticamente para cada extensi√≥n.

‚úÖ Paso 1 ‚Äì En tu c√≥digo (dentro de bosssecretary_get_config()), agreg√° esto:
php
Copiar
Editar
foreach ($groups as $group) {
    foreach ($group["bosses"] as $extension) {
        $ext->add("ext-local-custom", $extension, '', new ext_goto("1", $extension, BOSSSECRETARY_CONTEXT));
    }
}
Esto hace que cuando se llame, por ejemplo, al 300, FreePBX pase primero por ext-local-custom,300,1 que redirige a tu contexto especial ext-bosssecretary.

‚ú≥Ô∏è Qu√© hace esto:
Esto no reemplaza el plan de marcado principal, sino que sobrescribe el comportamiento para esa extensi√≥n cuando es llamada internamente, sin romper el dialplan de FreePBX.

üß† Por qu√© funciona:
Cada extensi√≥n en FreePBX tiene un contexto como ext-local, que incluye ext-local-custom al final.

Si agreg√°s algo como ext-local-custom,300, eso se ejecutar√° antes del contexto generado por FreePBX si hac√©s un Goto.

üìÅ Recomendaci√≥n extra:
No cambies el contexto base de la extensi√≥n desde el panel de FreePBX (o base de datos devices) porque:

Se rompe el plan de marcado generado por FreePBX.

Los cambios pueden perderse al actualizar o hacer reload.

üß™ Prob√° as√≠:
Recarg√° Asterisk:

bash
Copiar
Editar
fwconsole reload
Desde cualquier otra extensi√≥n (como la 501), llam√° al 300:
Verific√° que ahora Asterisk entra por ext-local-custom,300,1 y luego salta a tu l√≥gica.

üì¶ Bonus: ¬øQuer√©s que el 300 tambi√©n funcione externamente (from-pstn)?
Si quer√©s interceptar llamadas desde fuera (como el 1851 llamando al 300), ten√©s que agregar una entrada en from-pstn con algo como:

php
Copiar
Editar
$ext->add("from-pstn", "300", '', new ext_goto("1", "300", BOSSSECRETARY_CONTEXT));
Pero esto solo funciona si la llamada entra con DID 300 exacto.

¬øQuer√©s que te arme el bloque completo para agregar en bosssecretary_get_config() o ten√©s alguna l√≥gica distinta por DID?








T√∫ dijiste:
recapitulame que hacer para que la llamada desde el 1851 (externo, desde troncal) llegue al 300 (jefe, interno) sin tener que modificar el extensions_custom.conf, o sea que lo haga para cualquier jefe


ChatGPT Plus
Perfecto, vamos a recapitular paso a paso c√≥mo hacer que una llamada desde otra central (como la extensi√≥n 1851 v√≠a troncal) llegue correctamente a un jefe (como el 300) y ejecute tu m√≥dulo BossSecretary autom√°ticamente, sin tener que modificar extensions_custom.conf a mano.

üéØ Objetivo
Cuando alguien desde otra central llama al jefe (300), queremos:

‚úÖ Redirigir autom√°ticamente esa llamada al contexto de BossSecretary
‚úÖ Sin editar manualmente extensions_custom.conf
‚úÖ Funcione para cualquier jefe definido en tu m√≥dulo

üß© ¬øPor qu√© no funciona hoy?
Porque cuando una llamada entra desde la troncal, va al contexto from-pstn, y si el destino es 300, Asterisk lo trata como una extensi√≥n directa, sin pasar por ext-local-custom.

‚úÖ Soluci√≥n completa
üß± Paso 1 ‚Äì En tu m√≥dulo, dentro de bosssecretary_get_config(), agreg√° esto:
php
Copiar
Editar
foreach ($groups as $group) {
    foreach ($group["bosses"] as $extension) {
        // Para llamadas internas
        $ext->add("ext-local-custom", $extension, '', new ext_goto("1", $extension, BOSSSECRETARY_CONTEXT));

        // Para llamadas entrantes (from-pstn), si el DID coincide con el n√∫mero del jefe
        $ext->add("from-pstn", $extension, '', new ext_goto("1", $extension, BOSSSECRETARY_CONTEXT));
    }
}
üí° Este c√≥digo asegura que:

Si una extensi√≥n interna llama al jefe, se redirige a ext-bosssecretary.

Si una llamada desde una troncal entra con DID 300, tambi√©n se redirige a ext-bosssecretary.

üì¶ Paso 2 ‚Äì Verific√° que los DIDs en la troncal vengan con los n√∫meros internos correctos
Desde la otra central, al marcar #44 300, aseg√∫rate de que la llamada llegue con DID = 300. Pod√©s ver esto con:

bash
Copiar
Editar
asterisk -rvvv
Y buscar la l√≠nea como:

sql
Copiar
Editar
Called PJSIP/300
O:

css
Copiar
Editar
-- Executing [300@from-pstn:1]
üîÅ Paso 3 ‚Äì Hac√© fwconsole reload despu√©s de instalar o actualizar el m√≥dulo
Esto aplica los cambios en el plan de marcado generado autom√°ticamente.

bash
Copiar
Editar
fwconsole reload
üß™ Paso 4 ‚Äì Prob√° desde la otra central
Desde la extensi√≥n 1851 (en otra central), llam√° al jefe (300). Asterisk deber√≠a entrar por:

ini
Copiar
Editar
[from-pstn] exten => 300,1,Goto(ext-bosssecretary,300,1)
Y tu m√≥dulo deber√≠a ejecutarse.

‚úÖ Conclusi√≥n
‚úî Sin editar extensions_custom.conf
‚úî Compatible con m√∫ltiples jefes
‚úî Funciona desde llamadas internas y externas (troncal)

¬øQuer√©s que te pase el bloque completo final para pegar en bosssecretary_get_config()?








T√∫ dijiste:
no funciona. logs de asterisk:

  -- Executing [300@from-pstn:1] Set("PJSIP/pbxtucuman-00000027", "__DIRECTION=INBOUND") in new stack
    -- Executing [300@from-pstn:2] Gosub("PJSIP/pbxtucuman-00000027", "sub-record-check,s,1(in,300,dontcare)") in new stack
    -- Executing [s@sub-record-check:1] GotoIf("PJSIP/pbxtucuman-00000027", "0?initialized") in new stack
    -- Executing [s@sub-record-check:2] Set("PJSIP/pbxtucuman-00000027", "__REC_STATUS=INITIALIZED") in new stack
    -- Executing [s@sub-record-check:3] Set("PJSIP/pbxtucuman-00000027", "NOW=1752507478") in new stack
    -- Executing [s@sub-record-check:4] Set("PJSIP/pbxtucuman-00000027", "__DAY=14") in new stack
    -- Executing [s@sub-record-check:5] Set("PJSIP/pbxtucuman-00000027", "__MONTH=07") in new stack
    -- Executing [s@sub-record-check:6] Set("PJSIP/pbxtucuman-00000027", "__YEAR=2025") in new stack
    -- Executing [s@sub-record-check:7] Set("PJSIP/pbxtucuman-00000027", "__TIMESTR=20250714-123758") in new stack
    -- Executing [s@sub-record-check:8] Set("PJSIP/pbxtucuman-00000027", "__FROMEXTEN=unknown") in new stack
    -- Executing [s@sub-record-check:9] Set("PJSIP/pbxtucuman-00000027", "__MON_FMT=wav") in new stack
    -- Executing [s@sub-record-check:10] NoOp("PJSIP/pbxtucuman-00000027", "Recordings initialized") in new stack
    -- Executing [s@sub-record-check:11] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(ARG3=dontcare)") in new stack
    -- Executing [s@sub-record-check:12] Set("PJSIP/pbxtucuman-00000027", "REC_POLICY_MODE_SAVE=") in new stack
    -- Executing [s@sub-record-check:13] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(REC_STATUS=NO)") in new stack
    -- Executing [s@sub-record-check:14] GotoIf("PJSIP/pbxtucuman-00000027", "2?checkaction") in new stack
    -- Goto (sub-record-check,s,17)
    -- Executing [s@sub-record-check:17] GotoIf("PJSIP/pbxtucuman-00000027", "1?sub-record-check,in,1") in new stack
    -- Goto (sub-record-check,in,1)
    -- Executing [in@sub-record-check:1] NoOp("PJSIP/pbxtucuman-00000027", "Inbound Recording Check to 300") in new stack
    -- Executing [in@sub-record-check:2] Set("PJSIP/pbxtucuman-00000027", "FROMEXTEN=unknown") in new stack
    -- Executing [in@sub-record-check:3] ExecIf("PJSIP/pbxtucuman-00000027", "4?Set(FROMEXTEN=1851)") in new stack
    -- Executing [in@sub-record-check:4] Gosub("PJSIP/pbxtucuman-00000027", "recordcheck,1(dontcare,in,300)") in new stack
    -- Executing [recordcheck@sub-record-check:1] NoOp("PJSIP/pbxtucuman-00000027", "Starting recording check against dontcare") in new stack
    -- Executing [recordcheck@sub-record-check:2] Goto("PJSIP/pbxtucuman-00000027", "dontcare") in new stack
    -- Goto (sub-record-check,recordcheck,3)
    -- Executing [recordcheck@sub-record-check:3] Return("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [in@sub-record-check:5] Return("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [300@from-pstn:3] Set("PJSIP/pbxtucuman-00000027", "CHANNEL(tonezone)=us") in new stack
    -- Executing [300@from-pstn:4] Set("PJSIP/pbxtucuman-00000027", "__FROM_DID=300") in new stack
    -- Executing [300@from-pstn:5] Set("PJSIP/pbxtucuman-00000027", "returnhere=1") in new stack
    -- Executing [300@from-pstn:6] Gosub("PJSIP/pbxtucuman-00000027", "app-blacklist-check,s,1()") in new stack
    -- Executing [s@app-blacklist-check:1] GotoIf("PJSIP/pbxtucuman-00000027", "0?blacklisted") in new stack
    -- Executing [s@app-blacklist-check:2] Set("PJSIP/pbxtucuman-00000027", "CALLED_BLACKLIST=1") in new stack
    -- Executing [s@app-blacklist-check:3] Return("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [300@from-pstn:7] Set("PJSIP/pbxtucuman-00000027", "CDR(did)=300") in new stack
    -- Executing [300@from-pstn:8] GotoIf("PJSIP/pbxtucuman-00000027", "0?") in new stack
    -- Executing [300@from-pstn:9] ExecIf("PJSIP/pbxtucuman-00000027", "0 ?Set(CALLERID(name)=1851)") in new stack
    -- Executing [300@from-pstn:10] Set("PJSIP/pbxtucuman-00000027", "__MOHCLASS=") in new stack
    -- Executing [300@from-pstn:11] Set("PJSIP/pbxtucuman-00000027", "__REVERSAL_REJECT=FALSE") in new stack
    -- Executing [300@from-pstn:12] GotoIf("PJSIP/pbxtucuman-00000027", "1?post-reverse-charge") in new stack
    -- Goto (from-pstn,300,14)
    -- Executing [300@from-pstn:14] NoOp("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [300@from-pstn:15] Set("PJSIP/pbxtucuman-00000027", "__CALLINGNAMEPRES_SV=allowed_not_screened") in new stack
    -- Executing [300@from-pstn:16] Set("PJSIP/pbxtucuman-00000027", "__CALLINGNUMPRES_SV=allowed_not_screened") in new stack
    -- Executing [300@from-pstn:17] Set("PJSIP/pbxtucuman-00000027", "CALLERID(name-pres)=allowed_not_screened") in new stack
    -- Executing [300@from-pstn:18] Set("PJSIP/pbxtucuman-00000027", "CALLERID(num-pres)=allowed_not_screened") in new stack
    -- Executing [300@from-pstn:19] NoOp("PJSIP/pbxtucuman-00000027", "CallerID Entry Point") in new stack
    -- Executing [300@from-pstn:20] Set("PJSIP/pbxtucuman-00000027", "__CRM_DIRECTION=INBOUND") in new stack
    -- Executing [300@from-pstn:21] Set("PJSIP/pbxtucuman-00000027", "__CRM_SOURCE=1851") in new stack
    -- Executing [300@from-pstn:22] Set("PJSIP/pbxtucuman-00000027", "__CRM_LINKEDID=1752507478.222") in new stack
    -- Executing [300@from-pstn:23] AGI("PJSIP/pbxtucuman-00000027", "agi://127.0.0.1/sangomacrm.agi,true") in new stack
    -- <PJSIP/pbxtucuman-00000027>AGI Script agi://127.0.0.1/sangomacrm.agi completed, returning 0
    -- Executing [300@from-pstn:24] ExecIf("PJSIP/pbxtucuman-00000027", "1?Set(CHANNEL(hangup_handler_push)=crm-hangup,s,1)") in new stack
    -- Executing [300@from-pstn:25] Goto("PJSIP/pbxtucuman-00000027", "ext-group,400,1") in new stack
    -- Goto (ext-group,400,1)
    -- Executing [400@ext-group:1] GotoIf("PJSIP/pbxtucuman-00000027", "0?cid") in new stack
    -- Executing [400@ext-group:2] Set("PJSIP/pbxtucuman-00000027", "__MCGROUP=400") in new stack
    -- Executing [400@ext-group:3] PlayTones("PJSIP/pbxtucuman-00000027", "ring") in new stack
    -- Executing [400@ext-group:4] Progress("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [400@ext-group:5] Gosub("PJSIP/pbxtucuman-00000027", "macro-user-callerid,s,1()") in new stack
    -- Executing [s@macro-user-callerid:1] Set("PJSIP/pbxtucuman-00000027", "TOUCH_MONITOR=1752507478.222") in new stack
    -- Executing [s@macro-user-callerid:2] Set("PJSIP/pbxtucuman-00000027", "CHANCONTEXT=") in new stack
    -- Executing [s@macro-user-callerid:3] Set("PJSIP/pbxtucuman-00000027", "CHANCONTEXT=") in new stack
    -- Executing [s@macro-user-callerid:4] Set("PJSIP/pbxtucuman-00000027", "CHANEXTENCONTEXT=pbxtucuman-00000027") in new stack
    -- Executing [s@macro-user-callerid:5] Set("PJSIP/pbxtucuman-00000027", "CHANEXTEN=pbxtucuman-00000027") in new stack
    -- Executing [s@macro-user-callerid:6] Set("PJSIP/pbxtucuman-00000027", "CALLERID(number)=1851") in new stack
    -- Executing [s@macro-user-callerid:7] Set("PJSIP/pbxtucuman-00000027", "AMPUSER=1851") in new stack
    -- Executing [s@macro-user-callerid:8] Set("PJSIP/pbxtucuman-00000027", "HOTDESCKCHAN=pbxtucuman-00000027") in new stack
    -- Executing [s@macro-user-callerid:9] Set("PJSIP/pbxtucuman-00000027", "HOTDESKEXTEN=pbxtucuman") in new stack
    -- Executing [s@macro-user-callerid:10] Set("PJSIP/pbxtucuman-00000027", "HOTDESKCALL=0") in new stack
    -- Executing [s@macro-user-callerid:11] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(HOTDESKCALL=1)") in new stack
    -- Executing [s@macro-user-callerid:12] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(CALLERID(name)=)") in new stack
    -- Executing [s@macro-user-callerid:13] GotoIf("PJSIP/pbxtucuman-00000027", "0?report") in new stack
    -- Executing [s@macro-user-callerid:14] ExecIf("PJSIP/pbxtucuman-00000027", "1?Set(REALCALLERIDNUM=1851)") in new stack
    -- Executing [s@macro-user-callerid:15] Set("PJSIP/pbxtucuman-00000027", "AMPUSER=") in new stack
    -- Executing [s@macro-user-callerid:16] GotoIf("PJSIP/pbxtucuman-00000027", "0?limit") in new stack
    -- Executing [s@macro-user-callerid:17] Set("PJSIP/pbxtucuman-00000027", "AMPUSERCIDNAME=") in new stack
    -- Executing [s@macro-user-callerid:18] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(__CIDMASQUERADING=TRUE)") in new stack
    -- Executing [s@macro-user-callerid:19] GotoIf("PJSIP/pbxtucuman-00000027", "1?report") in new stack
    -- Goto (macro-user-callerid,s,28)
    -- Executing [s@macro-user-callerid:28] NoOp("PJSIP/pbxtucuman-00000027", "Macro depricated!! To keep the same line numbers") in new stack
    -- Executing [s@macro-user-callerid:29] NoOp("PJSIP/pbxtucuman-00000027", "Macro depricated !!  To keep the same line numbers") in new stack
    -- Executing [s@macro-user-callerid:30] GotoIf("PJSIP/pbxtucuman-00000027", "0?continue") in new stack
    -- Executing [s@macro-user-callerid:31] ExecIf("PJSIP/pbxtucuman-00000027", "1?Set(__CALLEE_ACCOUNCODE=)") in new stack
    -- Executing [s@macro-user-callerid:32] Set("PJSIP/pbxtucuman-00000027", "__TTL=64") in new stack
    -- Executing [s@macro-user-callerid:33] GotoIf("PJSIP/pbxtucuman-00000027", "1?continue") in new stack
    -- Goto (macro-user-callerid,s,49)
    -- Executing [s@macro-user-callerid:49] Set("PJSIP/pbxtucuman-00000027", "CALLERID(number)=1851") in new stack
       > 0x7fdc38050010 -- Strict RTP learning after remote address set to: 10.6.6.133:18328
    -- Executing [s@macro-user-callerid:50] Set("PJSIP/pbxtucuman-00000027", "CALLERID(name)=Negrete Joaquin") in new stack
    -- Executing [s@macro-user-callerid:51] GotoIf("PJSIP/pbxtucuman-00000027", "0?cnum") in new stack
    -- Executing [s@macro-user-callerid:52] Set("PJSIP/pbxtucuman-00000027", "__MCNUM=1851") in new stack
    -- Executing [s@macro-user-callerid:53] Set("PJSIP/pbxtucuman-00000027", "__MCNAME=Negrete Joaquin") in new stack
    -- Executing [s@macro-user-callerid:54] Set("PJSIP/pbxtucuman-00000027", "__MCEXTEN=") in new stack
    -- Executing [s@macro-user-callerid:55] Set("PJSIP/pbxtucuman-00000027", "__MCORGCHAN=PJSIP/pbxtucuman-00000027") in new stack
    -- Executing [s@macro-user-callerid:56] Set("PJSIP/pbxtucuman-00000027", "CDR(cnam)=Negrete Joaquin") in new stack
    -- Executing [s@macro-user-callerid:57] Set("PJSIP/pbxtucuman-00000027", "CDR(cnum)=1851") in new stack
    -- Executing [s@macro-user-callerid:58] Return("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [400@ext-group:6] Gosub("PJSIP/pbxtucuman-00000027", "macro-blkvm-setifempty,s,1()") in new stack
    -- Executing [s@macro-blkvm-setifempty:1] GotoIf("PJSIP/pbxtucuman-00000027", "1?init") in new stack
    -- Goto (macro-blkvm-setifempty,s,4)
    -- Executing [s@macro-blkvm-setifempty:4] Set("PJSIP/pbxtucuman-00000027", "__BLKVM_CHANNEL=PJSIP/pbxtucuman-00000027") in new stack
    -- Executing [s@macro-blkvm-setifempty:5] Set("PJSIP/pbxtucuman-00000027", "SHARED(BLKVM,PJSIP/pbxtucuman-00000027)=TRUE") in new stack
    -- Executing [s@macro-blkvm-setifempty:6] Set("PJSIP/pbxtucuman-00000027", "GOSUB_RETVAL=TRUE") in new stack
    -- Executing [s@macro-blkvm-setifempty:7] Return("PJSIP/pbxtucuman-00000027", "TRUE") in new stack
    -- Executing [400@ext-group:7] GotoIf("PJSIP/pbxtucuman-00000027", "1?skipov") in new stack
    -- Goto (ext-group,400,10)
    -- Executing [400@ext-group:10] Set("PJSIP/pbxtucuman-00000027", "RRNODEST=") in new stack
    -- Executing [400@ext-group:11] Set("PJSIP/pbxtucuman-00000027", "__NODEST=400") in new stack
    -- Executing [400@ext-group:12] GosubIf("PJSIP/pbxtucuman-00000027", "0?sub-rgsetcid,s,1()") in new stack
    -- Executing [400@ext-group:13] Gosub("PJSIP/pbxtucuman-00000027", "sub-record-check,s,1(rg,400,dontcare)") in new stack
    -- Executing [s@sub-record-check:1] GotoIf("PJSIP/pbxtucuman-00000027", "4?initialized") in new stack
    -- Goto (sub-record-check,s,10)
    -- Executing [s@sub-record-check:10] NoOp("PJSIP/pbxtucuman-00000027", "Recordings initialized") in new stack
    -- Executing [s@sub-record-check:11] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(ARG3=dontcare)") in new stack
    -- Executing [s@sub-record-check:12] Set("PJSIP/pbxtucuman-00000027", "REC_POLICY_MODE_SAVE=") in new stack
    -- Executing [s@sub-record-check:13] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(REC_STATUS=NO)") in new stack
    -- Executing [s@sub-record-check:14] GotoIf("PJSIP/pbxtucuman-00000027", "2?checkaction") in new stack
    -- Goto (sub-record-check,s,17)
    -- Executing [s@sub-record-check:17] GotoIf("PJSIP/pbxtucuman-00000027", "0?sub-record-check,rg,1") in new stack
    -- Executing [s@sub-record-check:18] NoOp("PJSIP/pbxtucuman-00000027", "Generic rg Recording Check - 1851 400") in new stack
    -- Executing [s@sub-record-check:19] Gosub("PJSIP/pbxtucuman-00000027", "recordcheck,1(dontcare,rg,400)") in new stack
    -- Executing [recordcheck@sub-record-check:1] NoOp("PJSIP/pbxtucuman-00000027", "Starting recording check against dontcare") in new stack
    -- Executing [recordcheck@sub-record-check:2] Goto("PJSIP/pbxtucuman-00000027", "dontcare") in new stack
    -- Goto (sub-record-check,recordcheck,3)
    -- Executing [recordcheck@sub-record-check:3] Return("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [s@sub-record-check:20] Return("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [400@ext-group:14] Set("PJSIP/pbxtucuman-00000027", "RingGroupMethod=firstavailable") in new stack
    -- Executing [400@ext-group:15] Set("PJSIP/pbxtucuman-00000027", "__ALT_CONFIRM_MSG=") in new stack
    -- Executing [400@ext-group:16] GotoIf("PJSIP/pbxtucuman-00000027", "0?RGVQANNOUNCE:NORGVQANNOUNCE") in new stack
    -- Goto (ext-group,400,19)
    -- Executing [400@ext-group:19] Gosub("PJSIP/pbxtucuman-00000027", "macro-dial,s,1(20,HhTtrQ(NO_ANSWER),301300)") in new stack
    -- Executing [s@macro-dial:1] NoOp("PJSIP/pbxtucuman-00000027", "Blind Transfer: , Attended Transfer: , User: , Alert Info: ") in new stack
    -- Executing [s@macro-dial:2] Set("PJSIP/pbxtucuman-00000027", "__CRM_SOURCE=1851") in new stack
    -- Executing [s@macro-dial:3] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:4] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:5] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(ALERT_INFO=)") in new stack
    -- Executing [s@macro-dial:6] ExecIf("PJSIP/pbxtucuman-00000027", "0?Set(CHANNEL(musicclass)=)") in new stack
    -- Executing [s@macro-dial:7] AGI("PJSIP/pbxtucuman-00000027", "agi://127.0.0.1/dialparties.agi") in new stack
 agi://127.0.0.1/dialparties.agi: Starting New Dialparties.agi
 agi://127.0.0.1/dialparties.agi: Caller ID name is 'Negrete Joaquin' number is '1851'
 agi://127.0.0.1/dialparties.agi: CW Ignore is:
 agi://127.0.0.1/dialparties.agi: CF Ignore is:
 agi://127.0.0.1/dialparties.agi: CW IN_USE/BUSY is: 1
 agi://127.0.0.1/dialparties.agi: Ringgroup confirm is  :
        > agi://127.0.0.1/dialparties.agi: USE_CONFIRMATION:  'FALSE'
        > agi://127.0.0.1/dialparties.agi: RINGGROUP_INDEX:   ''
 agi://127.0.0.1/dialparties.agi: Methodology of ring is  'firstavailable'
    -- agi://127.0.0.1/dialparties.agi: Added extension 301300 to extension map
    -- agi://127.0.0.1/dialparties.agi: Extension 301300 cf is disabled
    -- agi://127.0.0.1/dialparties.agi: Extension 301300 do not disturb is disabled
       > agi://127.0.0.1/dialparties.agi: extnum 301300 has:  cw: 0; hascfb: 0 [] hascfu: 0 []
 agi://127.0.0.1/dialparties.agi: EXTENSION_STATE: 4 (UNKNOWN)
 agi://127.0.0.1/dialparties.agi: Extension 301300 has ExtensionState: 4
    -- agi://127.0.0.1/dialparties.agi: Checking CW and CFB status for extension 301300
 agi://127.0.0.1/dialparties.agi: Extension 301300 is not available to be called
    -- agi://127.0.0.1/dialparties.agi: Filtered ARG3:
       > agi://127.0.0.1/dialparties.agi: NODEST: 400 adding U(macro-auto-blkvm) to dialopts: HhTtrQ(NO_ANSWER)U(macro-auto-blkvm)
       > agi://127.0.0.1/dialparties.agi: NODEST: 400 blkvm enabled macro already in dialopts: HhTtrQ(NO_ANSWER)U(macro-auto-blkvm)
 agi://127.0.0.1/dialparties.agi: Setting default NOANSWER DIALSTATUS since no extensions available
 agi://127.0.0.1/dialparties.agi: RVOL_MODE ''
 agi://127.0.0.1/dialparties.agi: RVOL is:
 agi://127.0.0.1/dialparties.agi: RVOLPARENT is:
    -- <PJSIP/pbxtucuman-00000027>AGI Script agi://127.0.0.1/dialparties.agi completed, returning 0
    -- Executing [s@macro-dial:8] GotoIf("PJSIP/pbxtucuman-00000027", "0?") in new stack
    -- Executing [s@macro-dial:9] NoOp("PJSIP/pbxtucuman-00000027", "Returned from dialparties with no extensions to call and DIALSTATUS: NOANSWER") in new stack
    -- Executing [s@macro-dial:10] Return("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [400@ext-group:20] Gosub("PJSIP/pbxtucuman-00000027", "sub-record-cancel,s,1()") in new stack
    -- Executing [s@sub-record-cancel:1] Return("PJSIP/pbxtucuman-00000027", "") in new stack
    -- Executing [400@ext-group:21] Set("PJSIP/pbxtucuman-00000027", "RingGroupMethod=") in new stack
    -- Executing [400@ext-group:22] GotoIf("PJSIP/pbxtucuman-00000027", "0?nodest") in new stack
    -- Executing [400@ext-group:23] Set("PJSIP/pbxtucuman-00000027", "__NODEST=") in new stack
    -- Executing [400@ext-group:24] Gosub("PJSIP/pbxtucuman-00000027", "macro-blkvm-clr,s,1()") in new stack
    -- Executing [s@macro-blkvm-clr:1] Set("PJSIP/pbxtucuman-00000027", "SHARED(BLKVM,PJSIP/pbxtucuman-00000027)=") in new stack
    -- Executing [s@macro-blkvm-clr:2] Set("PJSIP/pbxtucuman-00000027", "GOSUB_RETVAL=") in new stack
    -- Executing [s@macro
//$ext->add('from-pstn', '_.', '', new ext_execif('$["${DB(bosssecretary/group/member/${EXTEN})}" = "boss"]', 'Goto(bosssecretary-routing,${EXTEN},1)'));
				//$ext->add('from-pstn', '_.', '', new ext_goto('bosssecretary-routing,${EXTEN},1'));
			break;
	}

}


/********************************************************
*														*
* 					DATABASE FUNCTIONS					*
*														*
********************************************************/

function bosssecretary_get_groups()
{
	global $db;
	$sql = "SELECT * from bosssecretary_group";
	$results = $db->getAll($sql);
	if(DB::IsError($results)) {
		$results = null;
	}
	return $results;
}


function bosssecretary_get_fcc_toggle()
{
	$fcc = new featurecode('bosssecretary', 'bsc_toggle');
	$extLock = $fcc->getCodeActive();
	unset($fcc);
	return $extLock;
}

function bosssecretary_get_fcc_on()
{
	$fcc = new featurecode('bosssecretary', 'bsc_on');
	$extLock = $fcc->getCodeActive();
	unset($fcc);
	return $extLock;
}

function bosssecretary_get_fcc_off()
{
	$fcc = new featurecode('bosssecretary', 'bsc_off');
	$extLock = $fcc->getCodeActive();
	unset($fcc);
	return $extLock;
}

function bosssecretary_to_group($groups)
{
	$newGroup = array();

	foreach ($groups as $group)
	{
		$id = $group["id_group"];

		if (!isset($newGroup[$id]))
		{
			$newGroup[$id] = $group;
			$newGroup[$id]["bosses"] = array();
			$newGroup[$id]["secretaries"] = array();
			$newGroup[$id]["chiefs"] = array(); 

			if (!empty($group["boss_extension"])) {
				$newGroup[$id]["bosses"][$group["boss_extension"]] = $group["boss_extension"];
			}
			if (!empty($group["secretary_extension"])) {
				$newGroup[$id]["secretaries"][$group["secretary_extension"]] = $group["secretary_extension"];
			}
			if (!empty($group["chief_extension"])) {
				$newGroup[$id]["chiefs"][$group["chief_extension"]] = $group["chief_extension"];
			}
		}
		else
		{
			if (!empty($group["boss_extension"]) && !isset($newGroup[$id]["bosses"][$group["boss_extension"]])) {
				$newGroup[$id]["bosses"][$group["boss_extension"]] = $group["boss_extension"];
			}
			if (!empty($group["secretary_extension"]) && !isset($newGroup[$id]["secretaries"][$group["secretary_extension"]])) {
				$newGroup[$id]["secretaries"][$group["secretary_extension"]] = $group["secretary_extension"];
			}
			if (!empty($group["chief_extension"]) && !isset($newGroup[$id]["chiefs"][$group["chief_extension"]])) {
				$newGroup[$id]["chiefs"][$group["chief_extension"]] = $group["chief_extension"];
			}
		}
	}

	return $newGroup;
}

/*function bosssecretary_to_group($groups)
{
	$newGroup = array();
	foreach ($groups as $group)
	{
		if (!isset($newGroup[$group["id_group"]]))
		{
			$newGroup[$group["id_group"]] =  $group;
			$newGroup[$group["id_group"]]["bosses"] = array();
			// isset is so much faster than in_array ;)
			$newGroup[$group["id_group"]]["bosses"][$group["boss_extension"]] = $group["boss_extension"];

			$newGroup[$group["id_group"]]["secretaries"] = array();
			// isset is so much faster than in_array ;)
			$newGroup[$group["id_group"]]["secretaries"][$group["secretary_extension"]] = $group["secretary_extension"];

			if (isset($group["chief_extension"]))
			{
				$newGroup[$group["id_group"]]["chiefs"] = array();
				$newGroup[$group["id_group"]]["chiefs"][$group["chief_extension"]] = $group["chief_extension"];
			}
		}
		else
		{
			// isset is so much faster than in_array ;)
			if (!isset($newGroup[$group["id_group"]]["bosses"][$group["boss_extension"]]))
			{
				$newGroup[$group["id_group"]]["bosses"][$group["boss_extension"]] = $group["boss_extension"];
			}
			// isset is so much faster than in_array ;)
			if (!isset($newGroup[$group["id_group"]]["secretaries"][$group["secretary_extension"]]))
			{
				$newGroup[$group["id_group"]]["secretaries"][$group["secretary_extension"]] = $group["secretary_extension"];
			}
			if (!isset($newGroup[$group["id_group"]]["chiefs"][$group["chief_extension"]]))
			{
				$newGroup[$group["id_group"]]["chiefs"][$group["chief_extension"]] = $group["chief_extension"];
			}
		}
	}
	return $newGroup;
}*/

function bosssecretary_search($extensions)
{
	global $db;
	$extensions = explode(",", $extensions);
	foreach ($extensions as $extension)
	{
		if (is_numeric($extension))
		{
			$valid[]= trim($extension);
		}

	}
	if (!empty($valid))
	{
		$extensions = implode(",", $valid);
		$sql = "SELECT boss_extension AS extension, 'boss' as `type`, g.* FROM bosssecretary_group as g INNER JOIN bosssecretary_boss as b ON b.id_group = g.id_group  WHERE boss_extension IN ($extensions)
			UNION 
			SELECT secretary_extension AS extension, 'secretary' as `type`, g.* FROM bosssecretary_group as g INNER JOIN bosssecretary_secretary as s ON s.id_group = g.id_group  WHERE secretary_extension IN ($extensions)
			UNION
			SELECT chief_extension AS extension, 'chief' as `type`, g.* FROM bosssecretary_group as g INNER JOIN bosssecretary_chief as c ON c.id_group = g.id_group  WHERE chief_extension IN ($extensions)
";
		//echo $sql . "<br>";

		$results = $db->getAll($sql, array(), DB_FETCHMODE_ASSOC);
		if(DB::IsError($results)) {
			$results = null;
		}
		return $results;
	}
	return null;

}


function bosssecretary_get_all_groups()
{
	global $db;
	$sql = "SELECT
			g.id_group, 
			boss_extension, 
			secretary_extension,
			chief_extension  
		FROM bosssecretary_group AS g  
		INNER JOIN bosssecretary_boss AS b ON g.id_group = b.id_group 
		INNER JOIN bosssecretary_secretary AS s ON g.id_group = s.id_group
		LEFT JOIN bosssecretary_chief AS c ON g.id_group = c.id_group
;";
	$results = $db->getAll($sql, array(), DB_FETCHMODE_ASSOC);
	if(DB::IsError($results)) {
		$results = null;
	}
	return $results;
}

function bosssecretary_array_diff_with_db(array $exts, $group_number)
{
	global $db;


	if (!empty($exts))
	{
		if (bosssecretary_group_exists($group_number))
		{
			$sqlB = "AND id_group <> '" . $db->escapeSimple($group_number) . "'";
			$sqlS = "AND id_group <> '" . $db->escapeSimple($group_number) . "'";
		}
		else
		{
			$sqlB = $sqlS = "";
		}
		$exts = array_unique($exts);
		$strExts = bosssecretary_array_to_mysql_param_in($exts);

		$sql = "SELECT `boss_extension` AS `extension` FROM `bosssecretary_boss` WHERE boss_extension IN ($strExts) $sqlB
				UNION
				SELECT `secretary_extension` AS `extension` FROM `bosssecretary_secretary` WHERE secretary_extension IN ($strExts) $sqlS";

		$results = $db->getAll($sql, array(), DB_FETCHMODE_ASSOC);
		if(DB::IsError($results))
		{
			$results = null;
		}
		else
		{
			foreach ($results as $record)
			{
				if (($key = array_search($record['extension'], $exts)) !== FALSE)
				{
					unset($exts[$key]);
				}
			}
			$strExts = bosssecretary_array_to_mysql_param_in($exts);
			$sql = "SELECT extension FROM `users` WHERE extension IN ($strExts)";
			$results = $db->getAll($sql, array(), DB_FETCHMODE_ASSOC);
			if(DB::IsError($results))
			{
				$results = null;
			}
			else
			{
				$exts = array();
				foreach ($results as $record)
				{
					array_push($exts, current($record));
				}
			}

		}
	}
	return $exts;
}




function bosssecretary_clean_remove_duplicates( $bosses, $secretaries , $group_number = "")
{
	// Extraigo las extensiones de jefes del formulario
	$arr_bosses_extensions = bosssecretary_str_extensions_to_array($bosses);

	// Extraigo las extensiones de secretaria del formulario
	$arr_secretaries_extensions = bosssecretary_str_extensions_to_array($secretaries);

	// Quito de las extensiones de secretarias las extensiones que estan en los jefes
	$arr_secretaries_extensions = bosssecretary_array_diff($arr_secretaries_extensions, $arr_bosses_extensions);


	$extensionsCleaned = array();
	// Ahora quito de las extensiones de secretarias las extensiones que ya son jefes o secretarias segun la BD
	$extensionsCleaned["secretaries"] = bosssecretary_array_diff_with_db($arr_secretaries_extensions, $group_number);

	// Ahora quito de las extensiones de jefes las extensiones que ya son jefes o secretarias segun la BD
	$extensionsCleaned["bosses"] = bosssecretary_array_diff_with_db($arr_bosses_extensions, $group_number);
	return $extensionsCleaned;
}

function bosssecretary_get_group_number_free()
{
	global $db;
	$sql = "SELECT MIN(group_number) AS Bottom FROM bosssecretary_group_numbers_free ORDER BY group_number ASC LIMIT 1";
	$result = $db->getAll($sql, array(), DB_FETCHMODE_ASSOC);
	if(DB::IsError($result)) {
		$result = null;
	}
	if (!isset($result[0]["Bottom"]))
	{
		$sql = "SELECT MAX(id_group) AS Top FROM bosssecretary_group";
		$result = $db->getAll($sql, array(), DB_FETCHMODE_ASSOC);
		if(DB::IsError($result)) {
			$result = null;
		}
		if (!isset($result[0]["Top"]))
		{
			$next = 1;
		}
		else
		{
			$next = $result[0]["Top"] + 1;
		}
	}
	else
	{
		$next = $result[0]["Bottom"];
	}
	return $next;
}


function bosssecretary_set_group_number_free($number)
{
	global $db;
	$sql = "INSERT INTO bosssecretary_group_numbers_free VALUES ('$number')";
	//$result = $db->getAll($sql);
	return sql($sql);
}

function bosssecretary_remove_group_number_free($number)
{
	global $db;
	$sql = "DELETE FROM bosssecretary_group_numbers_free WHERE _rowid NOT IN (SELECT _rowid FROM bosssecretary_group) AND _rowid > (SELECT MAX(_rowid) FROM bosssecretary_group)";
	sql($sql);
	$sql = "DELETE FROM bosssecretary_group_numbers_free WHERE _rowid = '$number'";
	return sql($sql);
}



function bosssecretary_group_add ( $group_number, $group_label,  array $bosses, array $secretaries, $chiefs)
{
	global $db;
	$errors= array();
	if (is_numeric($group_number) or $group_number =="")
	{
		if (!bosssecretary_group_exists($group_number))
		{
			if (empty($bosses))
			{
				array_push($errors, "You must put one boss extension at least");
			}
			if (empty($secretaries))
			{
				array_push($errors, "You must put one secretary extension at least");
			}


			if (empty($errors))
			{
				$sql = "INSERT INTO bosssecretary_group (`id_group`, `label`) VALUES('".$db->escapeSimple($group_number)."', '".$db->escapeSimple($group_label)."')";
				sql($sql);
				//$group_number = mysql_insert_id();
				bosssecretary_remove_group_number_free($group_number);

				foreach ($bosses as $boss)
				{
					$boss = trim($boss);
					if (!empty($boss) and !(bosssecretary_extension_in_bosses_group($boss)))
					{
						$sql = "INSERT INTO bosssecretary_boss VALUES ('$group_number', '$boss')";
						sql($sql);
					}
					else
					{
						array_push($errors, "($boss) Extension exists already in another group like boss");
					}
				}
				foreach ($secretaries as $secretary)
				{
					$secretary = trim($secretary);
					if (!empty($secretary) and !(bosssecretary_extension_in_secretaries_group($secretary)))
					{
						$sql = "INSERT INTO bosssecretary_secretary VALUES ('$group_number', '$secretary')";
						sql($sql);
					}
					else
					{
						array_push($errors, "($secretary) Extension exists already in another group like secretary");
					}

				}
				if (is_array($chiefs))
				{
					foreach ($chiefs as $chief)
					{
						$chief = trim($chief);
						if (!empty($chief))
						{
							$sql = "INSERT INTO bosssecretary_chief VALUES ('$group_number', '$chief')";
							sql($sql);
						}
					}
				}
			}
		}
		else
		{
			array_push($errors, 'Group exists already');
		}
	}
	else
	{
		array_push($errors, 'Group number must be a numeric value');
	}
	return $errors;


}


function bosssecretary_group_edit ( $group_number, $group_label,  array $bosses, array $secretaries, array $chiefs)
{
	global $db;
	$errors= array();
	if (is_numeric($group_number))
	{
		if (bosssecretary_group_exists($group_number) )
		{
			if (empty($bosses))
			{
				array_push($errors, "You must put one boss extension at least");
			}
			if (empty($secretaries))
			{
				array_push($errors, "You must put one secretary extension at least");
			}

			if (empty($errors))
			{
				$sql = "DELETE FROM `bosssecretary_group` WHERE id_group = $group_number";
				sql($sql);

				$sql = "DELETE FROM `bosssecretary_boss` WHERE id_group = $group_number";
				sql($sql);

				$sql = "DELETE FROM `bosssecretary_secretary` WHERE id_group = $group_number";
				sql($sql);

				$sql = "DELETE FROM `bosssecretary_chief` WHERE id_group = $group_number";
				sql($sql);

				$sql = "INSERT INTO bosssecretary_group (`id_group`, `label`) VALUES('".$db->escapeSimple($group_number)."', '".$db->escapeSimple($group_label)."')";
				sql($sql);
				foreach ($bosses as $boss)
				{
					$boss = trim($boss);
					if (!empty($boss))
					{
						$sql = "INSERT INTO bosssecretary_boss VALUES ('$group_number', '$boss')";
						sql($sql);
					}
				}
				foreach ($secretaries as $secretary)
				{
					$secretary = trim($secretary);
					if (!empty($secretary))
					{
						$sql = "INSERT INTO bosssecretary_secretary VALUES ('$group_number', '$secretary')";
						sql($sql);
					}
				}

				foreach ($chiefs as $chief)
				{
					$chief = trim($chief);
					if (!empty($chief))
					{
						$sql = "INSERT INTO bosssecretary_chief VALUES ('$group_number', '$chief')";
						sql($sql);
					}
				}

			}
		}
		else
		{
			array_push($errors, "Group doesn't exists");
		}
	}
	else
	{
		array_push($errors, 'Group number must be a value numeric');
	}
	return $errors;


}

function bosssecretary_group_delete($group_number)
{
	global $db;
	$sql = "DELETE FROM `bosssecretary_group` WHERE id_group = '$group_number'";
	$group = sql($sql);


	$sql = "DELETE FROM `bosssecretary_boss` WHERE id_group = '$group_number'";
	$bosses = sql($sql);

	$sql = "DELETE FROM `bosssecretary_secretary` WHERE id_group = '$group_number'";
	$secretaries = sql($sql);

	$sql = "DELETE FROM `bosssecretary_chief` WHERE id_group = '$group_number'";
	$chiefs = sql($sql);

	bosssecretary_set_group_number_free($group_number);
	return (($group === $bosses) and ($group===$secretaries));
}

function bosssecretary_group_exists( $group)
{
	global $db;

	$sql = "SELECT 'true' from bosssecretary_group WHERE id_group='" . $db->escapeSimple($group). "' LIMIT 1";
	$results = $db->getAll($sql);
	if(DB::IsError($results)) {
		$results = null;
	}
	return count($results) == 1;
}





function bosssecretary_extension_in_bosses_group( $ext)
{
	global $db;
	$sql = "SELECT 'true' from bosssecretary_boss WHERE boss_extension='" . $db->escapeSimple($ext) . "' LIMIT 1";
	$results = $db->getAll($sql);
	if(DB::IsError($results)) {
		$results = null;
	}
	return count($results) == 1;
}


function bosssecretary_extension_in_secretaries_group( $ext)
{
	global $db;
	$sql = "SELECT 'true' from bosssecretary_secretary WHERE secretary_extension='" . $db->escapeSimple($ext) . "' LIMIT 1";
	$results = $db->getAll($sql);
	if(DB::IsError($results)) {
		$results = null;
	}
	return count($results) == 1;
}



function bosssecretary_get_data_of_group($group)
{
	global $db;

	// we use LEFT JOIN because at least we wanna to know info group (id_group and label)!
	$sql = "SELECT
			g.id_group, 
			g.label, 
			b.boss_extension, 
			s.secretary_extension,
			c.chief_extension  
		FROM bosssecretary_group AS g 
		LEFT JOIN bosssecretary_boss AS b ON b.id_group = g.id_group 
		LEFT JOIN bosssecretary_secretary AS s ON s.id_group = g.id_group
		LEFT JOIN bosssecretary_chief AS c ON c.id_group = g.id_group
		WHERE g.id_group='" .  $db->escapeSimple($group) . "'";

	$results = $db->getAll($sql, array(), DB_FETCHMODE_ASSOC);
	if(DB::IsError($results)) {
		$results = null;
	}
	return $results;
}



function bosssecretary_get_extension_data($ext){
	global $db;
	$sql = " SELECT extension, name FROM `users` u WHERE extension = '" .  $db->escapeSimple($ext) . "' LIMIT 1;";
	$results = $db->getAll($sql);

	if(DB::IsError($results)) {
		$results = array();
	}
	else{
		$results = current($results);
	}
	return $results;
}

function bosssecretary_extension_exists($ext){
	global $db;
	$sql = "SELECT 'true' FROM `users` WHERE extension = '" . $db->escapeSimple($ext) . "' LIMIT 1";
	$result = $db->getAll($sql);
	return count($result[0]) === 1;
}


/********************************************************
*														*
* 					UTILS FUNCTIONS						*
*														*
********************************************************/

/*

$haystack = array('a','b','c', 'd');
$needle = array('b','c', 'd','e');

$result = bosssecretary_array_diff($haystack, $needle);

$result is equal to array('a').

Yeah! I know! array_diff is a php function BUT is broken since v4.0.4 and we need it!
http://www.php.net/array_diff

*/


function bosssecretary_array_diff(array $haystack, array $needle)
{
	foreach ($needle as $value)
	{
		if (($key = array_search($value, $haystack)) !== FALSE)
		{
			unset($haystack[$key]);
		}
	}
	return $haystack;
}

/*

$haystack = array('a', 'b', 1, 10);

echo  bosssecretary_array_to_mysql_param_in($haystack);

output is:
'a', 'b', '1', '10'

*/


function bosssecretary_array_to_mysql_param_in(array $params)
{
	global $db;
	$arrParams = array();
	foreach ($params as $value)
	{
		array_push($arrParams, "'" .$db->escapeSimple($value). "'");
	}
	return implode(", ", $arrParams);
}




function bosssecretary_str_extensions_to_array($strExtensions)
{
	$strExtensions = trim($strExtensions);
	$strExtensions = str_replace(" ", "\n", $strExtensions);
	$arrExtensions = explode("\n", $strExtensions);
	foreach ($arrExtensions as $key => &$ext)
	{
		$ext = str_replace('\n','', $ext);
		$ext = trim($ext);
		if (empty($ext) and $ext != '0') // 0 is considered an empty string by some versions of php
		unset($arrExtensions[$key]);
	}
	return $arrExtensions;
}

function bosssecretary_create_nav_groups_links($groups, $dispnum)
{
	$links = array();
	$link["url"] = "config.php?display=$dispnum&bsgroupdisplay=".BOSSSECRETARY_PARAM_PREFIX. "add";
	$link["text"] = "Add Group";
	array_push($links, $link);
	if (!empty($groups))
	{
		foreach ($groups as $group)
		{
			$link["url"] = "config.php?display=$dispnum&bsgroupdisplay=".BOSSSECRETARY_PARAM_PREFIX . $group[0];
			if (trim($group[1]) == "" )
			{
				$group[1] = BOSSSECRETARY_LABEL_DEFAULT . $group[0];
			}
			$link["text"] = $group[0] . " (". $group[1].")";
			array_push($links, $link);
		}
	}
	return $links;
}

function bosssecretary_extract_group_from_request( $param)
{
	return ltrim($param, BOSSSECRETARY_PARAM_PREFIX); // easy, isn't it?
}


function bosssecretary_set_params_to_edit( $records)
{
	$vars = array();
	$first = current($records);
	$vars["group_number"] =  $first["id_group"];
	$vars["group_label"] =  $first["label"];

	if (trim($vars["group_label"]) == "")
	{
		$vars["group_label"] = BOSSSECRETARY_LABEL_DEFAULT . $vars["group_number"];
	}

	$vars["bosses_extensions"] = "";
	$vars["secretaries_extensions"] = "";
	$vars["chiefs_extensions"] = "";
	$s = array();
	$b = array();
	$c = array();
	foreach ($records as $record)
	{

		if (!empty($record["boss_extension"]))
		{
			array_push($b, $record["boss_extension"]);
		}
		if (!empty($record["secretary_extension"]))
		{
			array_push($s, $record["secretary_extension"]);
		}
		if (!empty($record["chief_extension"]))
		{
			array_push($c, $record["chief_extension"]);
		}
	}
	$vars["bosses"] = array_unique($b);
	$vars["secretaries"] = array_unique($s);
	$vars["chiefs"] = array_unique($c);
	return $vars;
}

/********************************************************
*														*
* 					GUI FUNCTIONS						*
*														*
********************************************************/


function bosssecretary_content($title, $content, $messages){
	echo <<<OUTPUT


<div class="content">
	<h2>$title</h2>
<script>
// AJAX to the SubCategory DropDown
function getExtensions(extensions)
{
	
	var url = "config.php?sid=" + Math.random() + "&display=bosssecretary&extensions=" + extensions + "&ajax=true";
	xmlHttp=GetXmlHttpObject(setExtensions);
	xmlHttp.open("GET", url , true);
	xmlHttp.send(null);
	document.getElementById('divExtensions').innerHTML = "Searching";
	return true;
}

function setExtensions()
{
	if (xmlHttp.readyState==4 || xmlHttp.readyState=="complete")
	{
		var datos;
		datos = (xmlHttp.responseText);
		document.getElementById('divExtensions').innerHTML = datos;
	}
}


function GetXmlHttpObject(handler){
	var objXmlHttp=null
	if (navigator.userAgent.indexOf("Opera")>=0){
		alert("This doesn't work in Opera")
		return
	}
	if (navigator.userAgent.indexOf("MSIE")>=0){
		var strName="Msxml2.XMLHTTP"
		if (navigator.appVersion.indexOf("MSIE 5.5")>=0){
			strName="Microsoft.XMLHTTP"
		}
		try{
			objXmlHttp=new ActiveXObject(strName)
			objXmlHttp.onreadystatechange=handler
			return objXmlHttp
		}catch(e){
			alert("Error. Scripting for ActiveX might be disabled")
			return
		}
	}
	if (navigator.userAgent.indexOf("Mozilla")>=0){
		objXmlHttp=new XMLHttpRequest()
		objXmlHttp.onload=handler
		objXmlHttp.onerror=handler
		return objXmlHttp
	}
}

</script>
<form method="post" name=searchbosssecretary action="config.php?display=bosssecretary" onsubmit="getExtensions(document.getElementById('extensions').value); return false;">
<table>
			<tr>
				<td colspan="2"><h5>Buscar grupo</h5> <hr /> </td>
			</tr>			
			<tr>
				<td colspan="2"><label>Extension:</label> <input type="text" id="extensions" name= "extension" value=""/> <input type="button" name="submitSearch" onclick="getExtensions(document.getElementById('extensions').value);" value="Search" /></td>				
			</tr>

			<tr>
				<td colspan="2"><div id="divExtensions"></div></td>
			</tr>
			<tr>
				<td colspan="2"><hr /></td>
			</tr>			
</table>
</form>

	$messages
	$content

</div>

OUTPUT;

}


function bosssecretary_get_form_add( array $params)
{
	$vars["form_title"] = "Add Group";
	$vars["form_url"] = "config.php?display=bosssecretary&bsgroupdisplay=".BOSSSECRETARY_PARAM_PREFIX. "add";
	$vars["bosses_extensions"] 		=	(isset($params["bosses"])) ? implode($params["bosses"], "\n") : '';
	$vars["secretaries_extensions"]	=	(isset($params["secretaries"])) ? implode($params["secretaries"], "\n") : '';
	$vars["chiefs_extensions"]	=	(isset($params["chiefs"])) ? implode($params["chiefs"], "\n") : '';
	$vars["group_label"] = (isset($params["group_label"])) ? $params["group_label"] : '';
	$vars["delete_button"] = "";
	$vars["action"] = "Add";
	$vars["message_details"] = $params["message_details"] ?? null;
	$vars["message_title"] = $params["message_title"] ?? null;
	return bosssecretary_get_form($vars);
}


function bosssecretary_get_form_edit(array $params)
{
    $vars = [];

    $vars["form_title"] = "Edit Group";
    $vars["form_url"] = "config.php?display=bosssecretary&bsgroupdisplay=" . urlencode($params["group_number"] ?? '');

    $vars["bosses_extensions"] = isset($params["bosses"]) && is_array($params["bosses"])
        ? implode(", ", $params["bosses"])
        : '';

    $vars["secretaries_extensions"] = isset($params["secretaries"]) && is_array($params["secretaries"])
        ? implode(", ", $params["secretaries"])
        : '';

    $vars["chiefs_extensions"] = isset($params["chiefs"]) && is_array($params["chiefs"])
        ? implode(", ", $params["chiefs"])
        : '';

    $vars["group_number"] = $params["group_number"] ?? '';
    $vars["group_label"] = $params["group_label"] ?? '';

    $vars["delete_button"] = bosssecretary_get_delete_button();
    $vars["action"] = "Edit";

    $vars["message_details"] = $params["message_details"] ?? '';
    $vars["message_title"] = $params["message_title"] ?? '';

    $vars["delete_question"] = "Do you really want to delete " . $vars["group_label"] . "?";

    $vars["delete_url"] = "config.php?display=bosssecretary&bsgroupdelete=" . urlencode($params["group_number"] ?? '');

    return bosssecretary_get_form($vars);
}



function bosssecretary_get_form ( array $vars)
{
	$sForm = file_get_contents(dirname(__FILE__). "/form_template.tpl");


	$vars["messages"] = "";
	if (!empty($vars["message_details"]))
	{
		$vars["messages"] = "<h5>".$vars["message_title"] . "</h5>";
		$vars["messages"] .= "<ul>";
		foreach ($vars["message_details"] as $details)
		{
			$vars["messages"] .= "<li>$details</li>";
		}
		$vars["messages"] .= "</ul>";
		unset($vars["message_details"]);
		unset($vars["message_title"]);
	}

	foreach ($vars as $var => $value) {
    		$sForm = str_replace("{" . $var . "}", $value ?? '', $sForm);
	}
	return $sForm;

}

function bosssecretary_get_delete_button()
{
	$sForm = file_get_contents(dirname(__FILE__). "/delete_button.tpl");
	return str_replace("{delete_button_label}", "Delete Group", $sForm);
}



function bosssecretary_show_nav_users($links){
	echo <<<OUTPUT

<div class="rnav">
	<ul>

OUTPUT;
	foreach ($links as $link){
		$url  = $link['url'];
		$text = $link['text'];

		echo <<<OUTPUT
		<li><a href="{$url}">{$text}</a></li>
	
OUTPUT;
}
echo <<<OUTPUT
	</ul>
</div>

OUTPUT;
}

?>
